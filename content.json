{"posts":[{"title":"分析ONOS Packet Processor Treatment無效之原因","text":"ONOS踩坑日記 前言最近嘗試使用ONOS目前最新的2.7版來開發APP，用OpenFlow來讓交換機實現router的功能。結果踩到ONOS Packet-in 封包處理實作未完全的坑。 當封包經過router時，會根據routing table和封包的目標決定要往哪個interface送出，同時將封包的source mac address改為交換機的mac address、封包的destination mac address改為nexthop的mac address。因此我們需要在交換機上安裝一條flow rule，selector是destination mac address，treatment有三個instructions分別是: 修改src mac、dst mac和決定output port。 為了減少交換機上的flow entry的數量，所以採用reactive的方式，也就是當交換機收到第一封包時，先將封包送(packet-in)給SDN controller，controller根據routing table，直接修改該封包的mac address，並從交換機特定的port送出(packet-out)，同時生成對應的flow rule並安裝到交換機上，後續的封包就可以直接根據flow rule轉送而不用再經過controller。 問題然而問題就出現在第一個封包上，根據tcpdump看到的結果，封包的source和destination mac address都沒有被修改到。 由於我是使用OVS來模擬Openflow交換機，因此首先懷疑是不是OVS本身實作限制，不支援同時包含上述三個instructions導致。然而，後續經過flow rule直接送出的封包，都有成功修改到mac address。由於只有第一個packet-in到controller，再packet-out回switch的封包沒有被修改，因此開始懷疑是ONOS的問題。 追蹤在ONOS裡面，一般使用PacketProcessor的方式來處理packet-in到controller的封包。首先實作PacketProcessor介面，然後向PacketService註冊，ONOS就會調用processor處理packet-in的封包。 1234567891011121314151617private PacketProcessor processor = new PacketProcessor() { @Override public void process(PacketContext context) { // ....處理封包的邏輯 // 修改設定封包的mac address和決定output port context.treatmentBuilder() .setEthSrc(srcMac) .setEthDst(dstMac) .setOutput(outPort.port()); context.send(); // 將封包packet-out回交換機 }}@Activateprotected void activate() { packetService.addProcessor(processor, PacketProcessor.director(1));} PacketContext會包含packet-in進來的封包內容，並可透過context.treatmentBuilder修改封包和決定要往哪個port送出去，最後透過send指令，packet-out回交換機。 搜查一下ONOS的原始碼，會在core/api下面找到DefaultPacketContext ，這個class實作了PacketContext這個Interface，但是這個class是一個abstract class，因此一定有人繼承了它，繼續搜查PacketContext這個字會找到兩個跟Openflow相關的，DefaultOpenFlowPacketContext和OpenFlowCorePacketContext，但是後者才有繼承DefaultPacketContext 和實作PacketContext介面，因此PacketProcesser在處理openflow packet-in進來的封包時，拿到的PacketContext具體應該是OpenFlowCorePacketContext這個class。 打開OpenFlowCorePacketContext.java會看到它實現了send這個function，經過簡單的檢查後呼叫sendPacket這個function，然後你就會看到… 123456789101112private void sendPacket(Ethernet eth) { List&lt;Instruction&gt; ins = treatmentBuilder().build().allInstructions(); OFPort p = null; // TODO: support arbitrary list of treatments must be supported in ofPacketContext for (Instruction i : ins) { if (i.type() == Type.OUTPUT) { p = buildPort(((OutputInstruction) i).port()); break; //for now... } } .......} 謎底揭曉，原來ONOS只有實作output這個instruction (決定output port)，因此它直接忽略的set source mac和set destination mac兩個指令，交換機送出來的封包當然就只有往對的port送，而沒有改到mac address。 結論結論就是在當前ONOS 2.7環境下，PacketProcesser在處理Openflow交換機封包packet-out的時候，只能決定該封包的output port，其餘對該封包的修改都是無效的。 參考資料 ONOS Source code","link":"/ONOS/Analyze-why-ONOS-Packet-Processor-Treatment-not-Work/"}],"tags":[],"categories":[{"name":"ONOS","slug":"ONOS","link":"/categories/ONOS/"}],"pages":[{"title":"about","text":"","link":"/about/index.html"}]}