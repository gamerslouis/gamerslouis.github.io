<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>學習 eBPF 系列 5 - BCC HTTP Filter &amp; Socket Filter - Louis Li&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Louis Li&#039;s Blog"><meta name="msapplication-TileImage" content="/img/mylogo.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Louis Li&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="這篇文章會介紹 eBPF socket filter 的概念，並使用 bcc 的 http-parse-simple.py 作為範例，來說明如何使用 eBPF socket filter 來過濾 HTTP 請求，並且會深入底下 eBPF 的 socket filter 底層部分的實作。"><meta property="og:type" content="blog"><meta property="og:title" content="學習 eBPF 系列 5 - BCC HTTP Filter &amp; Socket Filter"><meta property="og:url" content="https://blog.louisif.me/eBPF/Learn-eBPF-Serial-5-BCC-HTTP-Filter-Socket-Filter/"><meta property="og:site_name" content="Louis Li&#039;s Blog"><meta property="og:description" content="這篇文章會介紹 eBPF socket filter 的概念，並使用 bcc 的 http-parse-simple.py 作為範例，來說明如何使用 eBPF socket filter 來過濾 HTTP 請求，並且會深入底下 eBPF 的 socket filter 底層部分的實作。"><meta property="og:locale" content="zh_TW"><meta property="og:image" content="https://blog.louisif.me/img/my_og_image.png"><meta property="article:published_time" content="2022-10-31T08:18:42.000Z"><meta property="article:modified_time" content="2022-10-31T10:32:58.105Z"><meta property="article:author" content="Louis Li"><meta property="article:tag" content="eBPF"><meta property="article:tag" content="linux"><meta property="article:tag" content="bcc"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://blog.louisif.me/img/my_og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.louisif.me/eBPF/Learn-eBPF-Serial-5-BCC-HTTP-Filter-Socket-Filter/"},"headline":"學習 eBPF 系列 5 - BCC HTTP Filter & Socket Filter","image":["https://blog.louisif.me/img/og_image.png"],"datePublished":"2022-10-31T08:18:42.000Z","dateModified":"2022-10-31T10:32:58.105Z","author":{"@type":"Person","name":"Louis Li"},"publisher":{"@type":"Organization","name":"Louis Li's Blog","logo":{"@type":"ImageObject","url":"https://blog.louisif.me/img/mylogo.svg"}},"description":"這篇文章會介紹 eBPF socket filter 的概念，並使用 bcc 的 http-parse-simple.py 作為範例，來說明如何使用 eBPF socket filter 來過濾 HTTP 請求，並且會深入底下 eBPF 的 socket filter 底層部分的實作。"}</script><link rel="canonical" href="https://blog.louisif.me/eBPF/Learn-eBPF-Serial-5-BCC-HTTP-Filter-Socket-Filter/"><link rel="alternate" href="/atom.xml" title="Louis Li&#039;s Blog" type="application/atom+xml"><link rel="icon" href="/img/mylogo.svg"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.6.0/styles/atom-one-dark-reasonable.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-79VDS4QY8D" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-79VDS4QY8D');</script><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }
          Array
              .from(document.querySelectorAll('.tab-content'))
              .forEach($tab => {
                  $tab.classList.add('is-hidden');
              });
          Array
              .from(document.querySelectorAll('.tabs li'))
              .forEach($tab => {
                  $tab.classList.remove('is-active');
              });
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/mylogo.svg" alt="Louis Li&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/archives">Archives</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="文章目錄" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜尋" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><p class="level-item is-flex justify-content-center"><i class="fas fa-calendar mr-1"></i><span><time dateTime="2022-10-31T08:18:42.000Z" title="10/31/2022, 4:18:42 PM">2022-10-31</time>發表</span></p><p class="level-item is-flex justify-content-center"><i class="fas fa-folder mr-1"></i><span><a class="link-muted" href="/categories/eBPF/">eBPF</a></span></p><p class="level-item is-flex justify-content-center"><i class="fas fa-clock mr-1"></i><span>25 分鐘讀完 (大約3699個字)</span></p><p class="level-item is-flex justify-content-center"><i class="fas fa-person mr-1"></i><span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次訪問</span></p></div></div><h1 class="title is-3 is-size-4-mobile">學習 eBPF 系列 5 - BCC HTTP Filter &amp; Socket Filter</h1><div class="content"><p>這篇文章會介紹 eBPF socket filter 的概念，並使用 bcc 的 <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/tree/master/examples/networking/http_filter">http-parse-simple.py</a> 作為範例，來說明如何使用 eBPF socket filter 來過濾 HTTP 請求，並且會深入底下 eBPF 的 socket filter 底層部分的實作。</p>
<span id="more"></span>

<h2 id="Socket-filter-介紹"><a href="#Socket-filter-介紹" class="headerlink" title="Socket filter 介紹"></a>Socket filter 介紹</h2><p>前一篇文章介紹的 tcpconnect 是使用 <code>BPF_PROG_TYPE_KPROBE</code> 這個 program type，透過 kprobe&#x2F;kretprobe 機制在 kernel function 被呼叫和回傳的時候執行。</p>
<p>這次使用的是 <code>BPF_PROG_TYPE_SOCKET_FILTER</code>，socket filter 可以對進出 socket 的封包進行截斷或過濾。特別注意這邊如果會需要擷取封包 (長度不等於原始封包長度) 則會觸發對封包進行複製，然後修改封包大小。</p>
<p>socket filter program 會在 socket 層被呼叫 (在 net&#x2F;core&#x2F;sock.c 的 sock_queue_rcv_skb 被呼叫)，並傳入 <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/bpf.h#L5745">_sk_buff 結構</a> 取得 socket 上下文及封包的內容。</p>
<p>透過回傳的數值來決定如何處理該封包，如果回傳的數值大於等於封包長度，等價於保留完整封包，如果長度小於封包長度，則截斷只保留回傳數值長度的封包。其中兩個特例是回傳 0 和 - 1。回傳 0 等價解取一個長度為 0 的封包，也就是直接丟棄該封包。回傳 - 1 時，由於封包長度是無號整數，-1 等價於整數的最大數值，因此保證保留整個完整的封包。</p>
<p>另外一個關鍵技術是 raw socket，我們可以將 raw socket 監聽某個網路介面上所有進出封包。</p>
<p>因此整個程式的執行方式是這樣的，在目標網路卡上開啟一個 raw socket，透過 eBPF 程式過濾掉所有非 http 的封包，只保留 http 封包送出到 raw socket，userspace client 接收到封包時，可以直接解析封包欄位提取出 http 封包資訊。</p>
<h2 id="http-parse-simple-介紹"><a href="#http-parse-simple-介紹" class="headerlink" title="http-parse-simple 介紹"></a>http-parse-simple 介紹</h2><p>首先一樣先了解一下這支程式的功能，http-parse 能夠綁定到一張網路卡上面執行，然後提取經過 http 流量，將 http version, method, uri 和 status 輸出顯示。(當然如果經過 tls 加密的話是沒辦法的)</p>
<p>執行結果如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">python http-parse-complete.py <br>GET /pipermail/iovisor-dev/ HTTP/1.1<br>HTTP/1.1 200 OK<br>GET /favicon.ico HTTP/1.1<br>HTTP/1.1 404 Not Found<br>GET /pipermail/iovisor-dev/2016-January/thread.html HTTP/1.1<br>HTTP/1.1 200 OK<br>GET /pipermail/iovisor-dev/2016-January/000046.html HTTP/1.1<br>HTTP/1.1 200 OK<br></code></pre></td></tr></table></figure>

<h2 id="http-parse-simple-實作"><a href="#http-parse-simple-實作" class="headerlink" title="http-parse-simple 實作"></a>http-parse-simple 實作</h2><h3 id="eBPF-實作"><a href="#eBPF-實作" class="headerlink" title="eBPF 實作"></a>eBPF 實作</h3><p>在這次的程式中 eBPF c code 直接寫在一個獨立的 http-parse-simple.c 檔案中。</p>
<p>這次的 ebpf 程式很簡單只有單一個函數 <code>http_filter</code>，作為 socket filter 的進度點。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">http_filter</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> __sk_buff *skb)</span> &#123;<br><br>	u8 *cursor = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ethernet_t</span> *<span class="hljs-title">ethernet</span> =</span> cursor_advance (cursor, <span class="hljs-keyword">sizeof</span>(*ethernet));<br>	<span class="hljs-comment">//filter IP packets (ethernet type = 0x0800)</span><br>	<span class="hljs-keyword">if</span> (!(ethernet-&gt;type == <span class="hljs-number">0x0800</span>)) &#123;<br>		<span class="hljs-keyword">goto</span> DROP;<br>	&#125;<br>	<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ip_t</span> *<span class="hljs-title">ip</span> =</span> cursor_advance (cursor, <span class="hljs-keyword">sizeof</span>(*ip));<br><br>	<span class="hljs-comment">//drop the packet returning 0</span><br>	DROP:<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>...<br></code></pre></td></tr></table></figure>
<p>相信很多人跟我一樣第一眼看到這個程式會覺得非常疑惑，首先看到的是 <code>cursor</code> 和 <code>cursor_advance</code> 這兩個東西，從 ip 那行大概可以猜的出來，cursor 是對封包內容存取位置的指標，cursor_advance 會輸出當前 cursor 的位置，然後將 cursor 向後移動第二個參數的長度。<br>由於我們要分析的是 http 封包，所以他的 ether type 勢必得是 0x0800 (IP)，所以對於不滿足的封包，我們直接 goto 到 drop，return 0。表示我們要擷取一個長度為 0 的封包等價於丟棄該封包。</p>
<p>在 bcc 的 <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/src/cc/export/helpers.h">helpers.h</a> 輔助函數標頭檔裡面可以看到 cursor_advane 的定義。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//packet parsing state machine helpers<br>#define cursor_advance (_cursor, _len) \<br>  (&#123; void *_tmp = _cursor; _cursor += _len; _tmp; &#125;)<br></code></pre></td></tr></table></figure>
<p>果然符合我們的預期，先將原先 cursor 指標的數值保留起來，將 cursor 向後移動 len 後回傳原始數值。</p>
<p>後面的程式碼其實就很簡單，首先一路解析封包確保他是一個 ip&#x2F;tcp&#x2F;http 封包、封包長度夠長塞的下一個有效的 http 封包內容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">payload_offset = ETH_HLEN + ip_header_length + tcp_header_length;<br>...<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> p [<span class="hljs-number">7</span>];<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;<br>	p [i] = load_byte (skb, payload_offset + i);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>接著將 http packet 的前 7 個 byte 讀出來，load_byte 同樣是定義在 <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/src/cc/export/helpers.h">helpers.h</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">unsigned long long load_byte (void *skb,<br>	unsigned long long off) asm (&quot;llvm.bpf.load.byte&quot;);<br></code></pre></td></tr></table></figure>
<p>他會直接轉譯成 BPF_LD_ABS，從 payload_offset 位置開始讀一個 byte 出來，payload_offset，是前面算出來從 ethernet header 開始到 http payload 的位移。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//HTTP</span><br><span class="hljs-keyword">if</span> ((p [<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;H&#x27;</span>) &amp;&amp; (p [<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;T&#x27;</span>) &amp;&amp; (p [<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;T&#x27;</span>) &amp;&amp; (p [<span class="hljs-number">3</span>] == <span class="hljs-string">&#x27;P&#x27;</span>)) &#123;<br>	<span class="hljs-keyword">goto</span> KEEP;<br>&#125;<br><span class="hljs-comment">//GET</span><br><span class="hljs-keyword">if</span> ((p [<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;G&#x27;</span>) &amp;&amp; (p [<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;E&#x27;</span>) &amp;&amp; (p [<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;T&#x27;</span>)) &#123;<br>	<span class="hljs-keyword">goto</span> KEEP;<br>&#125;<br>...<br><span class="hljs-comment">//no HTTP match</span><br><span class="hljs-keyword">goto</span> DROP;<br><br><span class="hljs-comment">//keep the packet and send it to userspace returning -1</span><br>KEEP:<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br></code></pre></td></tr></table></figure>
<p>接著檢查如果封包屬於 HTTP (以 HTTP, GET, POST, PUT, DELETE HEAD… 開頭)，就會跳到 keep，保留整個完整的封包送到 userspace client program。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">GET /favicon.ico HTTP/1.1<br>HTTP/1.1 200 OK<br></code></pre></td></tr></table></figure>
<p>HTTP request 會以 method 開頭、response 會以 HTTP 開頭，所以需要查找這些字樣開頭的封包。</p>
<h3 id="python-實作"><a href="#python-實作" class="headerlink" title="python 實作"></a>python 實作</h3><p>接著我們很快速的來看一下 python 程式碼的部分。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">bpf = BPF (src_file = <span class="hljs-string">&quot;http-parse-simple.c&quot;</span>,debug = <span class="hljs-number">0</span>)<br>function_http_filter = bpf.load_func (<span class="hljs-string">&quot;http_filter&quot;</span>, BPF.SOCKET_FILTER)<br>BPF.attach_raw_socket (function_http_filter, interface)<br>socket_fd = function_http_filter.sock<br>sock = socket.fromfd (socket_fd,socket.PF_PACKET,socket.SOCK_RAW,socket.IPPROTO_IP)<br>sock.setblocking (<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>
<p>首先我們一樣透過 BPF 物件完成 bpf 程式碼的編譯，不一樣的是是這邊直接指定 src_file 從檔案讀取。<br>接著透過 load_func，指定 socket filter 這個 program type type 和 http_filter 這個入口函數，並載入 ebpf bytecode 到 kernel<br>接著透過 bcc 提供的 attach_raw_socket API 在 interface 上建立 row socket 並將 socket filter program attach 上去。<br>接著從 <code>function_http_filter.sock</code> 取得 raw socket 的 file descripter 並封裝成 python 的 socket 物件。<br>由於後面需要 socket 是阻塞的，但是 attach_raw_socket 建立出來的 socket 是非阻塞的，所以這邊透過 <code>sock.setblocking (True)</code> 阻塞 socket</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">while 1:<br>  #retrieve raw packet from socket<br>  packet_str = os.read (socket_fd,2048)<br>  packet_bytearray = bytearray (packet_str)<br>  ...<br>  for i in range (payload_offset,len (packet_bytearray)-1):<br>    if (packet_bytearray [i]== 0x0A): # \n<br>      if (packet_bytearray [i-1] == 0x0D): \r<br>        break # 遇到 http 的換行 \r\n 則結束 < br>    print (&quot;% c&quot; % chr (packet_bytearray [i]), end = &quot;&quot;)<br></code></pre></td></tr></table></figure>
<p>後面的程式碼其實就和 ebpf 的部分大同小異，從 socket 讀取封包內容、解析到 http payload 後，將 http payload 的第一行輸出出來。</p>
<p>到此我們就完成了 <code>http-parse-simple</code> 的解析。</p>
<h3 id="問題"><a href="#問題" class="headerlink" title="問題"></a>問題</h3><ol>
<li>cursor 指標數值為 0，但是可以存取到封包的內容。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">u8 *cursor = <span class="hljs-number">0</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ethernet_t</span> *<span class="hljs-title">ethernet</span> =</span> cursor_advance (cursor, <span class="hljs-keyword">sizeof</span>(*ethernet));<br><span class="hljs-keyword">if</span> (!(ethernet-&gt;type == <span class="hljs-number">0x0800</span>)) &#123;<br>		<span class="hljs-keyword">goto</span> DROP;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>特別的 load_bytes 函數呼叫，來取得封包內容<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">load_byte (skb, payload_offset + i);<br></code></pre></td></tr></table></figure></li>
</ol>
<p>首先雖然 ebpf 使用 c 來編寫，但是經由 LLVM 編譯後會轉換成 eBPF bytecode，在進入 kernel 後會再經過 verifier 的修改。(經過這次的探索，可以理解 verifier 雖然叫做 verifier，但是他的功能確包羅萬象，對 eBPF 架構來說非常重要)</p>
<h2 id="深入了解-Socket-filter"><a href="#深入了解-Socket-filter" class="headerlink" title="深入了解 Socket filter"></a>深入了解 Socket filter</h2><p>為了理解這段 eBPF code 後面發生了什麼事，我們先查看 LLVM 編譯出來的 eBPF bytecode。</p>
<h3 id="BCC-Debug"><a href="#BCC-Debug" class="headerlink" title="BCC Debug"></a>BCC Debug</h3><p>在 BCC 編譯時，我們可以透過 <code>debug</code> 這個參數取得編譯過程中的資訊，當然也包含取得 LLVM 編譯出來的 eBPF bytecode，可以使用的 debug 選項如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Debug flags</span><br><br><span class="hljs-comment"># Debug output compiled LLVM IR.</span><br>DEBUG_LLVM_IR = <span class="hljs-number">0x1</span><br><span class="hljs-comment"># Debug output loaded BPF bytecode and register state on branches.</span><br>DEBUG_BPF = <span class="hljs-number">0x2</span><br><span class="hljs-comment"># Debug output pre-processor result.</span><br>DEBUG_PREPROCESSOR = <span class="hljs-number">0x4</span><br><span class="hljs-comment"># Debug output ASM instructions embedded with source.</span><br>DEBUG_SOURCE = <span class="hljs-number">0x8</span><br><span class="hljs-comment"># Debug output register state on all instructions in addition to DEBUG_BPF.</span><br>DEBUG_BPF_REGISTER_STATE = <span class="hljs-number">0x10</span><br><span class="hljs-comment"># Debug BTF.</span><br>DEBUG_BTF = <span class="hljs-number">0x20</span><br></code></pre></td></tr></table></figure>

<h3 id="解析-simple-http-parse-編譯結果"><a href="#解析-simple-http-parse-編譯結果" class="headerlink" title="解析 simple-http-parse 編譯結果"></a>解析 simple-http-parse 編譯結果</h3><p>透過 <code>BPF (src=&#39;simple-http-parse.c&#39;, debug=DEBUG_PREPROCESSOR)</code>，我們可以看到上面的 code 被 LLVM 重新解釋為</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *cursor = <span class="hljs-number">0</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ethernet_t</span> *<span class="hljs-title">ethernet</span> =</span> cursor_advance (cursor, <span class="hljs-keyword">sizeof</span>(*ethernet));<br><br><span class="hljs-comment">//filter IP packets (ethernet type = 0x0800)</span><br><span class="hljs-keyword">if</span> (!(bpf_dext_pkt (skb, (u64) ethernet+<span class="hljs-number">12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">16</span>) == <span class="hljs-number">0x0800</span>)) &#123;<br>	<span class="hljs-keyword">goto</span> DROP;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>因此 cursor 在這邊的用途真的只是計算 offset。<br>bpf_dext_pkt 在 bcc 的 <a target="_blank" rel="noopener" href="https://github.com/iovisor/bcc/blob/master/src/cc/export/helpers.h">helper.h</a> 有所定義</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">u64 <span class="hljs-title function_">bpf_dext_pkt</span><span class="hljs-params">(<span class="hljs-type">void</span> *pkt, u64 off, u64 bofs, u64 bsz)</span> &#123;<br>  <span class="hljs-keyword">if</span> (bofs == <span class="hljs-number">0</span> &amp;&amp; bsz == <span class="hljs-number">8</span>) &#123;<br>    <span class="hljs-keyword">return</span> load_byte (pkt, off);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bofs + bsz &lt;= <span class="hljs-number">8</span>) &#123;<br>    <span class="hljs-keyword">return</span> load_byte (pkt, off) &gt;&gt; (<span class="hljs-number">8</span> - (bofs + bsz))  &amp;  MASK (bsz);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bofs == <span class="hljs-number">0</span> &amp;&amp; bsz == <span class="hljs-number">16</span>) &#123;<br>     <span class="hljs-keyword">return</span> load_half (pkt, off);<br>  ... <br></code></pre></td></tr></table></figure>
<p>可以看到他是根據參數大小和類型去正確呼叫 load_byte, load_half, load_dword 系列函數，所以其實他做的事情與我們感興趣的第二段 code <code>load_byte (skb, payload_offset + i);</code> 是一致的。</p>
<p>接著我們使用 <code>BPF (src=&#39;simple-http-parse.c&#39;, debug=DEBUG_SOURCE)</code> 查看編譯出來的 eBPF binary code。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">; <span class="hljs-type">int</span> <span class="hljs-title function_">http_filter</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> __sk_buff *skb)</span> &#123; <span class="hljs-comment">// Line  27</span><br>   <span class="hljs-number">0</span>:	bf <span class="hljs-number">16</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>	r6 = r1<br>   <span class="hljs-number">1</span>:	<span class="hljs-number">28</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">0</span>c <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>	r0 = *(u16 *) skb [<span class="hljs-number">12</span>]<br>; <span class="hljs-keyword">if</span> (!(bpf_dext_pkt (skb, (u64) ethernet+<span class="hljs-number">12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">16</span>) == <span class="hljs-number">0x0800</span>)) &#123; <span class="hljs-comment">// Line  34</span><br>   <span class="hljs-number">2</span>:	<span class="hljs-number">55</span> <span class="hljs-number">00</span> <span class="hljs-number">5</span>c <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">08</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>	<span class="hljs-keyword">if</span> r0 != <span class="hljs-number">2048</span> <span class="hljs-keyword">goto</span> +<span class="hljs-number">92</span><br></code></pre></td></tr></table></figure>
<p>其中 r0, r1, r6 是 eBPF 的 register，我們這邊只關注第 1 行 <code>r0 = *(u16 *) skb [12]</code>，這行是從 skb 的第 12 個 byte 拿取資料出來，剛好對應到 bpf_dext_pkt。</p>
<p>根據 ebpf instruction set 的定義，第一個 byte 28 (0010 1000) 是 op code。<br>最後 3 個 bit 000 是 op code 的種類。這邊的 0x00 對應到 <code>BPF_LD</code> (non-standard load operations)</p>
<p>|3 bits (MSB) | 2 bits|3 bits (LSB)|<br>|———— |—–‐——|—–‐——|<br>| mode | size | instruction class|</p>
<p>在 <code>BPF_LD</code> 這個分類內，size bits 01 剛好對應到 <code>BPF_H</code> (half word (2 bytes))<br>最前面的 3 個 bit 000 代表 <code>BPF_ABS</code>(legacy BPF packet access)。</p>
<p>到這邊我們就理解它是怎麼運作了了，eBPF 定義了 <code>BPF_ABS</code> 來代表對封包的存取操作，LLVM 在編譯的時會將對 skb 的 load_byte 轉譯成對應的 instruction。</p>
<h3 id="了解-eBPF-BPF-ABS-instruction"><a href="#了解-eBPF-BPF-ABS-instruction" class="headerlink" title="了解 eBPF BPF_ABS instruction"></a>了解 eBPF BPF_ABS instruction</h3><p>我們可以更深入的了解一下 eBPF 對 <code>BPF_ABS</code> 做了什麼事情，在 verifier 這個神奇的地方搜尋 <code>BPF_ABS</code> 這個 instruction，會找到下面這段內容 (簡化版)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Implement LD_ABS and LD_IND with a rewrite, if supported by the program type. */</span><br><span class="hljs-keyword">if</span> (BPF_CLASS (insn-&gt;code) == BPF_LD &amp;&amp;<br>	(BPF_MODE (insn-&gt;code) == BPF_ABS ||<br>	 BPF_MODE (insn-&gt;code) == BPF_IND)) &#123;<br>	<br>	cnt = env-&gt;ops-&gt;gen_ld_abs (insn, insn_buf);<br>	new_prog = bpf_patch_insn_data (env, i + delta, insn_buf, cnt);<br></code></pre></td></tr></table></figure>
<p>首先執行條件是 <code>BPF_LD</code> 及 <code>BPF_ABS</code>，我們的 code 剛好符合這個條件，接著會呼叫 <code>env-&gt;ops-&gt;gen_ld_abs</code>，根據原本的 instrunction <code>insn</code>，生成新的 instruction 寫入 <code>insn_buf</code>，接著呼叫 <code>bpf_patch_insn_data</code> 將原本的指令取代為新的指令。</p>
<p>接著我們要找一下 <code>gen_ld_abs</code>，跟 day 11 介紹 map 的情況類似，verifier 定義了 bpf_verifier_ops 結構，讓不同的 program type 根據需要，實作 bpf_verifier_ops 定義的 function 來提供不同的功能和行為。</p>
<p>socket filter 的定義如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bpf_verifier_ops</span> <span class="hljs-title">sk_filter_verifier_ops</span> =</span> &#123;<br>	.get_func_proto		= sk_filter_func_proto,<br>	.is_valid_access	= sk_filter_is_valid_access,<br>	.convert_ctx_access	= bpf_convert_ctx_access,<br>	.gen_ld_abs		= bpf_gen_ld_abs,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>所以讓我們看到 <code>bpf_gen_ld_abs</code> (一樣經過簡化只看我們需要的部分)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bpf_gen_ld_abs</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> bpf_insn *insn,</span><br><span class="hljs-params">			  <span class="hljs-keyword">struct</span> bpf_insn *insn_buf)</span><br>&#123;<br>	*insn++ = BPF_MOV64_REG (BPF_REG_2, orig-&gt;src_reg);<br><br><span class="hljs-comment">/* We&#x27;re guaranteed here that CTX is in R6. */</span><br>	*insn++ = BPF_MOV64_REG (BPF_REG_1, BPF_REG_CTX);<br><br>	*insn++ = BPF_EMIT_CALL (bpf_skb_load_helper_16_no_cache);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>看到最後一行就很清晰了，最後其實等於調用了內部使用的 helper function 來存取資料。eBPF 也提提供了類似的 helper function <code>bpf_skb_load_bytes</code>，來提供存取封包內容的功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">BPF_CALL_2 (bpf_skb_load_helper_16_no_cache, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sk_buff *, skb,<br>	   <span class="hljs-type">int</span>, offset)<br>&#123;<br>	<span class="hljs-keyword">return</span> ____bpf_skb_load_helper_16 (skb, skb-&gt;data, skb-&gt;len - skb-&gt;data_len,<br>					  offset);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>而 bpf_skb_load_helper_16_no_cache 其實就是直接從 <code>sk_buff-&gt;data</code> 的位置取得資料，data 是 sk_buff 用來指到封包開頭的指標。</p>
<h3 id="sk-buff-的限制"><a href="#sk-buff-的限制" class="headerlink" title="__sk_buff 的限制"></a>__sk_buff 的限制</h3><p>既然整個指令的本質是從 <code>sk_buff-&gt;data</code> 拿取資料，那我們是不是能夠直接從 <code>__sk_buff</code> 裡面拿到資料呢？</p>
<p>在 socket program type 下 program context 是 <code>__sk_buff</code>，他其實本質是對 sk_buff 的多一層封裝 (原因 <a target="_blank" rel="noopener" href="https://lwn.net/Articles/636647">參見</a>)，在執行的時候，verifier 換將其取代回 sk_buff，因此__sk_buff 等於是 sk_buff 暴露出來的介面。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">struct __sk_buff &#123;<br>	...<br>	__u32 data;<br>	__u32 data_end;<br>	__u32 napi_id;<br>	...<br></code></pre></td></tr></table></figure>
<p>參考__sk_buff 的定義，<code>__sk_buff</code> 是有定義將 <code>data</code> 和 <code>data_end</code>，那我們原始的 eBPF 程式是不是可以改成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">void *cursor = (void*)(long)(__sk_buff-&gt;data);<br>struct ethernet_t *ethernet = cursor_advance (cursor, sizeof (*ethernet));<br>if (!(ethernet-&gt;type == 0x0800)) &#123;<br>		goto DROP;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果完成這樣的修改，重新跑一遍 <code>http-parse-simple.py</code>，你會得到</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">python3 http-parse-simple.py -i eno0<br>binding socket to &#x27;enp0s3&#x27;<br>bpf: Failed to load program: Permission denied<br>; int http_filter (struct __sk_buff *skb) &#123;<br>0: (bf) r6 = r1<br>; void *cursor = (void*)(long) skb-&gt;data;<br>1: (61) r7 = *(u32 *)(r6 +76)<br>invalid bpf_context access off=76 size=4<br>processed 2 insns (limit 1000000) max_states_per_insn 0 total_states 0 peak_states 0 mark_read 0<br><br>Traceback (most recent call last):<br>  File &quot;http-parse-simple.py&quot;, line 69, in &lt;module&gt;<br>    function_http_filter = bpf.load_func (&quot;http_filter&quot;, BPF.SOCKET_FILTER)<br>  File &quot;/usr/lib/python3/dist-packages/bcc/__init__.py&quot;, line 526, in load_func<br>    raise Exception (&quot;Failed to load BPF program % s: % s&quot; %<br>Exception: Failed to load BPF program b&#x27;http_filter&#x27;: Permission denied<br></code></pre></td></tr></table></figure>
<p>可以看到程式碼被 verifier 拒絕，並拿到了一個 <code>invalid bpf_context access off=76 size=4</code> 的錯誤，表示存取 <code>__sk_buff-&gt;data</code> 是非法的。</p>
<p>回去追蹤程式碼的話，會看到在 verifier 裡面會用 <code>env-&gt;ops-&gt;is_valid_access</code> 來檢查該存取是否有效，這同樣定義在 <code>bpf_verifier_ops</code> 結構內。</p>
<p>其中 socket filter program 的實作是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">static bool sk_filter_is_valid_access (int off, int size,<br>				      enum bpf_access_type type,<br>				      const struct bpf_prog *prog,<br>				      struct bpf_insn_access_aux *info)<br>&#123;<br>	switch (off) &#123;<br>	case bpf_ctx_range (struct __sk_buff, tc_classid):<br>	case bpf_ctx_range (struct __sk_buff, data):<br>	case bpf_ctx_range (struct __sk_buff, data_meta):<br>	case bpf_ctx_range (struct __sk_buff, data_end):<br>	case bpf_ctx_range_till (struct __sk_buff, family, local_port):<br>	case bpf_ctx_range (struct __sk_buff, tstamp):<br>	case bpf_ctx_range (struct __sk_buff, wire_len):<br>	case bpf_ctx_range (struct __sk_buff, hwtstamp):<br>		return false;<br>	&#125;<br>	...<br></code></pre></td></tr></table></figure>
<p>可以很直接看到拒絕了 data 的存取。</p>
<p>從 linux kernel 的 <a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/db58ba45920255e967cc1d62a430cebd634b5046">變更紀錄</a> 來推測，data 欄位好像本來就不是給 socket filter 使用的，只是單純因為 cls_bpf 和 socker filter 可能共用了這部分的程式碼，因此要額外阻擋這部分的 code 不讓使用。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>最後還有一個沒解決的問題，<code>u8 *cursor = 0;</code>，為甚麼空指標經過 LLVM 編譯後會編譯成對 skb 的存取還是未知的，看起來像是 BCC 特別的機制，但是找不太到相關資料，只好保留這個問題。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/v5.17/bpf/instruction-set.html">eBPF Instruction Set</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/61702223/bpf-verifier-rejects-code-invalid-bpf-context-access">Stackoverflow: invalid bpf_context access”</a></li>
<li><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html">bpf-helpers man page</a></li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>學習 eBPF 系列 5 - BCC HTTP Filter &amp; Socket Filter</p><p><a href="https://blog.louisif.me/eBPF/Learn-eBPF-Serial-5-BCC-HTTP-Filter-Socket-Filter/">https://blog.louisif.me/eBPF/Learn-eBPF-Serial-5-BCC-HTTP-Filter-Socket-Filter/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Louis Li</p></div></div><div class="level-item is-narrow"><div><h6>發表於</h6><p>2022-10-31</p></div></div><div class="level-item is-narrow"><div><h6>更新於</h6><p>2022-10-31</p></div></div><div class="level-item is-narrow"><div><h6>許可協議</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/eBPF/">eBPF</a><a class="link-muted mr-2" rel="tag" href="/tags/linux/">linux</a><a class="link-muted mr-2" rel="tag" href="/tags/bcc/">bcc</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/eBPF/Learn-eBPF-Serial-6-XDP-BCC-xdp-redirect-map/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">學習 eBPF 系列 6 - XDP &amp; BCC xdp_redirect_map</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/eBPF/Learn-eBPF-Serial-4-BCC-tcpconnect/"><span class="level-item">學習 eBPF 系列 4 - BCC tcpconnect</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">評論</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://blog.louisif.me/eBPF/Learn-eBPF-Serial-5-BCC-HTTP-Filter-Socket-Filter/';
            this.page.identifier = 'eBPF/Learn-eBPF-Serial-5-BCC-HTTP-Filter-Socket-Filter/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'louis-lis-blog' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/mylogo.svg" alt="Louis Li"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Louis Li</p><p class="is-size-6 is-block">NYCU CS</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Hsinchu, Taiwan</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">18</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分類</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">標籤</p><a href="/tags"><p class="title">14</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/gamerslouis" target="_blank" rel="noopener">追蹤</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/gamerslouis"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Mail" href="mailto:me@louisif.me"><i class="fas fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分類</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Kubernetes/"><span class="level-start"><span class="level-item">Kubernetes</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/ONOS/"><span class="level-start"><span class="level-item">ONOS</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Openstack/"><span class="level-start"><span class="level-item">Openstack</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Terraform/"><span class="level-start"><span class="level-item">Terraform</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/eBPF/"><span class="level-start"><span class="level-item">eBPF</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/notes/"><span class="level-start"><span class="level-item">notes</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-11-02T17:49:46.000Z">2022-11-03</time></p><p class="title"><a href="/Openstack/Solve-Openstack-vm-create-fail/">解決 Openstack VM 建立失敗問題</a></p><p class="categories"><a href="/categories/Openstack/">Openstack</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-11-02T16:47:08.000Z">2022-11-03</time></p><p class="title"><a href="/Openstack/Openstack-Deployment-Serial-3-Basic-Management-Commands/">Openstack 架設系列文章 (3) - 基本指令操作</a></p><p class="categories"><a href="/categories/Openstack/">Openstack</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-11-01T13:00:57.000Z">2022-11-01</time></p><p class="title"><a href="/notes/Install-openvpn-client-on-proxmox/">Proxmox 安裝 openvpn client 紀錄</a></p><p class="categories"><a href="/categories/notes/">notes</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-11-01T13:00:00.000Z">2022-11-01</time></p><p class="title"><a href="/Openstack/Openstack-Deployment-Serial-2-Deployment-with-Openstack-Ansible/">Openstack 架設系列文章 (2) - 使用 Openstack Ansible 部署 Openstack</a></p><p class="categories"><a href="/categories/Openstack/">Openstack</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-10-31T10:14:40.000Z">2022-10-31</time></p><p class="title"><a href="/eBPF/Learn-eBPF-Serial-9-eBPF-helper-functions/">學習 eBPF 系列 9 - eBPF helper functions</a></p><p class="categories"><a href="/categories/eBPF/">eBPF</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">彙整</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/11/"><span class="level-start"><span class="level-item">十一月 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">十月 2022</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/09/"><span class="level-start"><span class="level-item">九月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/08/"><span class="level-start"><span class="level-item">八月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">標籤</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/P4/"><span class="tag">P4</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ansible/"><span class="tag">ansible</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bcc/"><span class="tag">bcc</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cgroups/"><span class="tag">cgroups</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/eBPF/"><span class="tag">eBPF</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iaC/"><span class="tag">iaC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/openstack/"><span class="tag">openstack</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/openvpn/"><span class="tag">openvpn</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/proxmox/"><span class="tag">proxmox</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/socketmap/"><span class="tag">socketmap</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tc/"><span class="tag">tc</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/terraform/"><span class="tag">terraform</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xdp/"><span class="tag">xdp</span><span class="tag">1</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">文章目錄</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Socket-filter-介紹"><span class="level-left"><span class="level-item">1</span><span class="level-item">Socket filter 介紹</span></span></a></li><li><a class="level is-mobile" href="#http-parse-simple-介紹"><span class="level-left"><span class="level-item">2</span><span class="level-item">http-parse-simple 介紹</span></span></a></li><li><a class="level is-mobile" href="#http-parse-simple-實作"><span class="level-left"><span class="level-item">3</span><span class="level-item">http-parse-simple 實作</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#eBPF-實作"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">eBPF 實作</span></span></a></li><li><a class="level is-mobile" href="#python-實作"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">python 實作</span></span></a></li><li><a class="level is-mobile" href="#問題"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">問題</span></span></a></li></ul></li><li><a class="level is-mobile" href="#深入了解-Socket-filter"><span class="level-left"><span class="level-item">4</span><span class="level-item">深入了解 Socket filter</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#BCC-Debug"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">BCC Debug</span></span></a></li><li><a class="level is-mobile" href="#解析-simple-http-parse-編譯結果"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">解析 simple-http-parse 編譯結果</span></span></a></li><li><a class="level is-mobile" href="#了解-eBPF-BPF-ABS-instruction"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">了解 eBPF BPF_ABS instruction</span></span></a></li><li><a class="level is-mobile" href="#sk-buff-的限制"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">__sk_buff 的限制</span></span></a></li></ul></li><li><a class="level is-mobile" href="#結語"><span class="level-left"><span class="level-item">5</span><span class="level-item">結語</span></span></a></li><li><a class="level is-mobile" href="#參考資料"><span class="level-left"><span class="level-item">6</span><span class="level-item">參考資料</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/mylogo.svg" alt="Louis Li&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2022 Louis Li</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>個訪客</span></p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-TW");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到頁首" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此網站使用Cookie來改善您的體驗。",
          dismiss: "知道了！",
          allow: "允許使用Cookie",
          deny: "拒絕",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="請輸入關鍵字..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"請輸入關鍵字...","untitled":"(無標題)","posts":"文章","pages":"頁面","categories":"分類","tags":"標籤"});
        });</script></body></html>