<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Louis Li&#39;s Blog</title>
  
  
  <link href="https://blog.louisif.me/atom.xml" rel="self"/>
  
  <link href="https://blog.louisif.me/"/>
  <updated>2022-09-04T18:01:07.821Z</updated>
  <id>https://blog.louisif.me/</id>
  
  <author>
    <name>Louis Li</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CNI Spec 導讀</title>
    <link href="https://blog.louisif.me/Kubernetes/CNI-Spec-Guiding/"/>
    <id>https://blog.louisif.me/Kubernetes/CNI-Spec-Guiding/</id>
    <published>2022-09-04T16:57:00.000Z</published>
    <updated>2022-09-04T18:01:07.821Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>這次來嘗試寫寫看 spec 導讀，今天要講的是 <a href="https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md">Container Network Interface (CNI) Specification</a>。CNI 是 <a href="https://cncf.io/">CNCF</a> 的一個專案，這個專案包含了今天要講的 CNI SPEC 以及基於這個 SPEC 開發出來 libraries 還有一系列的 CNI plugins。</p><span id="more"></span> <p>CNI 定義了一套 plugin-based 的網路解決方案，包含了設定還有呼叫執行的標準，使用 CNI 最知名的專案應該就是 kubernetes 了，在 k8s 環境中，容器的網路並不是直接由 container runtime (ex. Docker) 處理的，container runtime 建立好容器後，kubelet 就會依照 CNI 的設定和通訊標準去呼叫 CNI plugin，由 CNI plugin 來完成容器的網路設置。</p><p>Container runtime 在執行容器建立時，會依據設定檔 (後續稱為 network configuration) 的指示，依序呼叫一個或多個的 CNI plugin 來完成網路功能的設置，一個網路功能的設置可能會需要多個 CNI plugins 之間的相互合作，或著由多個 CNI plugin 提供多個不同的網路功能。</p><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>目前 CNI spec 的版本是 1.0.0，CNI 的 repository 裡面除了 spec 文件外也包含了基於 CNI spec 開發的 go library，用於 CNI plugin 的開發。不過 CNI spec 和 library 的版本號是獨立的，當前的 library 版本是 1.1.2。</p><p>首先要對幾個基本名詞定義</p><ul><li>container 是一個網路獨立的環境，在 linux 上通常透過 network namespace 的機制來切割，不過也可能是一個獨立的 VM。</li><li>network 是 endpoints 的集合，每個 endpoint 都有著一個唯一是別的的地址 (通常是 ip address) 可用於互相通訊。一個端點可能是一個容器、VM 或著路由器之類的網路設備。</li><li>runtime 指的是呼叫執行 CNI plugin 的程式，以 k8s 來說，kubelet 作為這個角色</li><li>plugin 指的是一個用來完成套用特定網路設定的程式。</li></ul><p>CNI Spec 包含五個部分</p><ol><li>Network configuration format: CNI 網路設定的格式</li><li>Execution Protocol: runtime 和 CNI plugin 之間溝通的 protocol</li><li>Execution of Network Configurations: 描述 runtime 如何解析 network configuration 和操作 CNI plugin。</li><li>Plugin Delegation: 描述 CNI plugin 如何呼叫 CNI plugin。</li><li>Result Types: 描述 CNI plugin 回傳的結果格式。</li></ol><h2 id="Section-1-Network-configuration-format"><a href="#Section-1-Network-configuration-format" class="headerlink" title="Section 1: Network configuration format"></a>Section 1: Network configuration format</h2><p>CNI 定義了一個網路設定的格式，這個格式用於 runtime 讀取的設定檔，也用於 runtime 解析後，plugin 接收的格式，通常來說設定檔是以 ** 靜態 ** 檔案的方式存在主機上，不會任意變更。</p><p>CNI 使用了 JSON 作為設定檔的格式，並包含以下幾個主要欄位</p><ul><li><code>cniVersion</code> (string): 對應的 CNI spec 版本，當前是 1.0.0</li><li><code>name</code> (string): 一個在主機上不重複的網路名稱</li><li><code>disableCheck</code> (boolean): 如果 disableCheck 是 true 的話，runtime 就不能呼叫 <code>CHECK</code>，<code>CHECK</code> 是 spec 定義的一個指令用來檢查網路是否符合 plugin 依據設定的結果，由於一個網路設定可能會呼叫多個 CNI plugins，因此可能會出現網路狀態符合管理員預期，但是 CNI plugin 之間衝突檢查失敗的情況，這時就可以設定 disableCheck</li><li><code>plugin</code> (list): CNI plugin 設定 (Plugin configuration object) 的列表。</li></ul><h3 id="Plugin-configuration-object"><a href="#Plugin-configuration-object" class="headerlink" title="Plugin configuration object"></a><strong>Plugin configuration object</strong></h3><p>plugin configuration object 包含了一些明定的欄位，但 CNI plugin 可能根據需要增加欄位，會由 runtime 在不修改的情況下送給 CNI plugin。</p><ul><li>必填:<ul><li><code>type</code> (string): CNI plugin 的執行檔名稱</li></ul></li><li>可選欄位 (CNI protocol 使用):<ul><li><code>capabilities</code> (dictionary): 定義 CNI plugin 支援的 capabilities，後面在 <a href="#Deriving-execution-configuration-from-plugin-configuration">section 3</a> 會介紹。</li></ul></li><li>保留欄位：這些欄位是在執行過程中，由 runtime 生成出來的，因此不應該在設定檔內被定義。<ul><li><code>runtimeConfig</code></li><li><code>args</code></li><li>任何 <code>cni.dev/</code> 開頭的 key</li></ul></li><li>可選欄位：不是 protocol 定義的欄位，但是由於很多 CNI plugin 都有使用，因此具有特定的意義。<ul><li>ipMasq (boolean): 如果 plugin 支援的話，會在 host 上替該網路設置 IP masquerade，如果 host 要做為該網路的 gateway 的話，可能需要該功能。</li><li>ipam (dictionary): IPAM (IP Address Management) 設置，後面在 <a href="#Section-4-Plugin-Delegation">section 4</a> 會介紹。</li><li>dns (dictionary): DNS 設置相關設置<ul><li>nameservers (list of strings): DNS server 的 IP 列表</li><li>domain (string): DNS search domain</li><li>search (list of strings),: DNS search domain 列表</li><li>options (list of strings): DNS options 列表</li></ul></li></ul></li><li>其他欄位: CNI plugin 自己定義的額外欄位。</li></ul><p>設定檔範例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>  <span class="hljs-string">&quot;cniVersion&quot;</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;dbnet&quot;</span>,<br>  <span class="hljs-string">&quot;plugins&quot;</span>: [<br>    &#123;<br>      <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;bridge&quot;</span>,<br>      <span class="hljs-comment">//plugin specific parameters</span><br>      <span class="hljs-string">&quot;bridge&quot;</span>: <span class="hljs-string">&quot;cni0&quot;</span>,<br>      <span class="hljs-string">&quot;keyA&quot;</span>: [<span class="hljs-string">&quot;some more&quot;</span>, <span class="hljs-string">&quot;plugin specific&quot;</span>, <span class="hljs-string">&quot;configuration&quot;</span>],<br>      <br>      <span class="hljs-string">&quot;ipam&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;host-local&quot;</span>,<br>        <span class="hljs-comment">//ipam specific</span><br>        <span class="hljs-string">&quot;subnet&quot;</span>: <span class="hljs-string">&quot;10.1.0.0/16&quot;</span>,<br>        <span class="hljs-string">&quot;gateway&quot;</span>: <span class="hljs-string">&quot;10.1.0.1&quot;</span>,<br>        <span class="hljs-string">&quot;routes&quot;</span>: [<br>            &#123;<span class="hljs-string">&quot;dst&quot;</span>: <span class="hljs-string">&quot;0.0.0.0/0&quot;</span>&#125;<br>        ]<br>      &#125;,<br>      <span class="hljs-string">&quot;dns&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;nameservers&quot;</span>: [ <span class="hljs-string">&quot;10.1.0.1&quot;</span> ]<br>      &#125;<br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;tuning&quot;</span>,<br>      <span class="hljs-string">&quot;capabilities&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;mac&quot;</span>: <span class="hljs-literal">true</span><br>      &#125;,<br>      <span class="hljs-string">&quot;sysctl&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;net.core.somaxconn&quot;</span>: <span class="hljs-string">&quot;500&quot;</span><br>      &#125;<br>    &#125;,<br>    &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;portmap&quot;</span>,<br>        <span class="hljs-string">&quot;capabilities&quot;</span>: &#123;<span class="hljs-string">&quot;portMappings&quot;</span>: <span class="hljs-literal">true</span>&#125;<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Section-2-Execution-Protocol"><a href="#Section-2-Execution-Protocol" class="headerlink" title="Section 2: Execution Protocol"></a>Section 2: Execution Protocol</h2><p>CNI 的工作模式是由 container runtime 去呼叫 CNI plugin 的 binaries，CNI Protocol 定義了 runtime 和 plugin 之間的溝通標準。</p><p>CNI plugin 的工作是完成容器網路介面的某種設置，大致上可以分成兩類</p><ul><li>Interface plugin: 建立容器內的網路介面，並確保其連接可用</li><li>Chained plugin: 調整修改一個已建立的介面 (可能同時會需要建立更多額外的介面)</li></ul><p>Runtime 透過兩種方式傳遞參數，一是透過環境變數，二是透過 stdin 傳遞 Section 1 定義的 configuration。如果成功的話，結果會透過 stdout 傳遞，如果失敗的話就會錯誤資訊會透過 stderr 傳遞。configuration 和結果、錯誤都是使用 JSON 格式。</p><p>Runtime 必須在 Runtime 的網路執行，大多數情況下就是在主機的預設 network namespace&#x2F;dom0</p><h3 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h3><p>Protocol 的參數都是透過環境變數來傳遞的，可能的參數如下</p><ul><li>CNI_COMMAND: 當前執行的 CNI 操作 (可能是 <code>ADD</code>, <code>DEL</code>, <code>CHECK</code>. <code>VERSION</code>)</li><li>CNI_CONTAINERID: 容器的ＩＤ</li><li>CNI_NETNS: 容器網路空間的參考，如果是使用 namespaces 的方式來切割的話，就是 namespce 的路徑（e.g. <code>/run/netns/[nsname]</code> )</li><li>CNI_IFNAME: 要建立在容器內的介面名稱，如果 plugin 無法建立該名稱則回傳錯誤</li><li>CNI_ARGS: 其他參數，Alphanumeric 格式的 key-value pairs，使用分號隔開”e.g. <code>FOO=BAR;ABC=123</code></li><li>CNI_PATH: CNI plugin 的搜尋路徑，因為 CNI 存在 CNI plugin 呼叫 CNI plugin 的情況，所以需要這個路徑。如果包含多個路徑，使用 OS 定義的分隔符號分割。Linux 使用 <code>:</code> ，Windows 使用 <code>;</code></li></ul><h3 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a>Errors</h3><p>如果執行成功，CNI Plugin 應該回傳 0。如果失敗則回傳非 0，並從 stderr 回傳 error result type structure。</p><h3 id="CNI-operations"><a href="#CNI-operations" class="headerlink" title="CNI operations"></a>CNI operations</h3><h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><p>CNI plugin 會在 <code>CNI_NETNS</code> 內建立 <code>CNI_IFNAME</code> 介面或對該介面套用特定的設置</p><p>如果 CNI plugin 執行成功，應該從 stdout 回傳一個 result structure。如果 plugin 的 stdin 輸入包含 prevResult，他必些直接把 prevResult 包在 result structure 內或對他修改後在包在 result structure 內，runtime 會把前一個 CNI 輸出的 prevResult 包在下一個 CNI 的 stdin 輸入內。</p><p>如果 CNI plugin 嘗試建立介面時，該介面已經存在，應該發出錯誤。</p><p>Runtime 不應該在沒有 DEL 的情況下對一個 <code>CNI_CONTAINERID</code> 容器的一個 <code>CNI_IFNAME</code> 介面多次呼叫 ADD。不過可能對同一個 container 的不同介面呼叫 ADD。</p><p>必有的輸入包含 STDIN JSON configuration object、 <code>CNI_COMMAND</code>、<code>CNI_CONTAINERID</code> 、 <code>CNI_NETNS</code> 和 <code>CNI_IFNAME</code> 。 <code>CNI_ARGS</code> 和 <code>CNI_PATH</code> 為可選項。</p><h4 id="DEL"><a href="#DEL" class="headerlink" title="DEL"></a>DEL</h4><p>移除 <code>CNI_NETNS</code> 內的 <code>CNI_IFNAME</code> 介面，或還原 ADD 套用的網路設定</p><p>通常來說，如果要釋放的資源已經不存在，DEL 也應該視為成功。例如容器網路已經不存在了，一個 IPAM plugin 應該還是要正常的釋放 IP 和回傳成功，除非 IPAM plugin 對容器網路存在與否有嚴格的要求。即便是 DHCP plugin，雖然執行 DEL 操作的時侯，需要透過容器網路發送 DHCP release 訊息，但是由於 DHCP leases 有 lifetime 的機制，超時後會自動回收，因此即便容器網路不存在，DHCP plugin 在執行 DEL 操作時，也應該該回傳成功。</p><p>如果重複對一個 <code>CNI_CONTAINERID</code> 容器的 <code>CNI_IFNAME</code> 介面執行多次 DEL 操作，plguin 都應該回傳，即便介面已經不存在或 ADD 套用的修改已經還原。</p><p>必有的輸入包含 STDIN JSON configuration object、 <code>CNI_COMMAND</code>、<code>CNI_CONTAINERID</code> 和 <code>CNI_IFNAME</code>。 <code>CNI_NETNS</code>、<code>CNI_ARGS</code> 和 <code>CNI_PATH</code> 為可選項。</p><h4 id="CHECK"><a href="#CHECK" class="headerlink" title="CHECK"></a>CHECK</h4><p>Runtime 透過 <code>CHECK</code> 檢查容器的狀態，並確保容器網路符合預期。CNI spec 可以分為 plugin 和 runtime 的兩部分</p><p>Plugin:</p><ul><li><p>plugin 必須根據 <code>prevResult</code> 來判斷介面和地址是否符合預期</p></li><li><p>plugin 必須接受其他 chained plugin 對介面修改的結果</p></li><li><p>如果 plugin 建立並列舉在 <code>prevResult</code> 的 CNI Result type 資源 (介面、地址、路由規則) 不存在或不符合預期狀態，plugin 應該回傳錯誤</p></li><li><p>如果其他不在 Result type 內的資源不存在或不符合預期也應該回垂錯誤。可能的資源如下</p><ul><li>防火牆規則</li><li>流量控管 (Traffic shaping controls)</li><li>IP 保留 (Reservation)</li><li>外部依賴，如連接所需的 daemon</li></ul></li><li><p>如果發現容器網路是無法訪問的應該回傳錯誤</p></li><li><p>plugin 必須在完成 <code>ADD</code> 後能夠立即處理 <code>CHECK</code> 指令，應此 plguin 應該要容忍非同步完成的網路設置在一定的時間內不符合預期。</p></li><li><p>plugin 執行 <code>CHECK</code> 時，應該呼叫所有 delegated plugin 的 <code>CHECK</code>，並把 delegated plugin 的錯誤傳給 plugin 的呼叫者</p></li></ul><p>Runtime:</p><ul><li>Runtime 不應該在未執行 <code>ADD</code> 前或已經 <code>DEL</code> 後沒在執行一次 <code>ADD</code> 的容器執行 <code>CHECK</code></li><li>如果 configuration 的 disableCheck 為真，runtime 不應呼叫 disableCheck</li><li>Runtime 呼叫 <code>CHECK</code> 時，configuration 必須在 <code>prevResult</code> 包含前一次 <code>ADD</code> 操作時最後一個 plugin 的 Result。Runtime 可能會使用 libcni 提供的 Result caching 功能。</li><li>如果其中一個 plugin 回傳錯誤，runtime 可能不會呼叫後面 plugin 的 <code>CHECK</code></li><li>Runtime 可能會在 <code>ADD</code> 完後的下一刻一直到 <code>DEL</code> 執行前的任何時間執行 <code>CHECK</code></li><li>Runtime 可能會假設一個 <code>CHECK</code> 失敗的容器會永久處於配置錯誤的狀態</li></ul><p>必有的輸入包含 STDIN JSON configuration object、 <code>CNI_COMMAND</code>、<code>CNI_CONTAINERID</code>、<code>CNI_NETNS</code> 和 <code>CNI_IFNAME</code>。 <code>CNI_ARGS</code> 和 <code>CNI_PATH</code> 為可選項。</p><p>除了 <code>CNI_PATH</code> 以外的參數必須和 <code>ADD</code> 時一致。</p><h4 id="VERSION"><a href="#VERSION" class="headerlink" title="VERSION"></a>VERSION</h4><p>Plugin 透過 stdout 輸出 JSON 格式的 version result type object，用於查看 CNI plugin 的版本。</p><p>Stdin 輸入的 JSON 物件只包含 <code>cniVersion</code>。<br>環境變數參數只需要 <code>CNI_COMMAND</code>。</p><h2 id="Section-3-Execution-of-Network-Configurations"><a href="#Section-3-Execution-of-Network-Configurations" class="headerlink" title="Section 3: Execution of Network Configurations"></a>Section 3: Execution of Network Configurations</h2><p>這個章節描述了 runtime 如何解析 network configuration，並執行 CNI plugins。Runtime 可能會想要新增、刪除、檢查 configuration，並對應到 CNI plugin 的 <code>ADD</code>, <code>DELETE</code>, <code>CHECK</code> 操作。這個章節也定義 configuration 是如何改變並提供給 plugin 的。</p><p>對容器的 network configuration 操作稱之為 attachment，一個 attachment 通常對應到一個特定 <code>CNI_CONTAINERID</code> 容器的 <code>CNI_IFNAME</code> 介面。</p><h3 id="生命週期"><a href="#生命週期" class="headerlink" title="生命週期"></a>生命週期</h3><ul><li>Runtime 必須在呼叫任何 CNI Plugin 之前，為容器建立新的 network namespace</li><li>Runtime 一定不能同時在一個容器執行多個 plugin 命令，但是同時處理多個容器是可以的。因此 plugin 必須能夠處理多容器 concurrency 的問題，並在共享的資源 (e.g. IPAM DB) 實作 lock 機制</li><li>Runtime 必須確保 <code>ADD</code> 操作後必定執行一次 <code>DEL</code> 操作，即便 <code>ADD</code> 失敗。唯一可能的例外是如結點直接丟失之類的災難性事件。</li><li><code>DEL</code> 操作可能連續多次執行</li><li>network configuration 在 ADD 和 DEL 操作之間，以及不同的為 attachment 之間應該保持一致不變</li><li>runtime 必須負責清除容器的 network namespace</li></ul><h3 id="Attachment-Parameters"><a href="#Attachment-Parameters" class="headerlink" title="Attachment Parameters"></a>Attachment Parameters</h3><p>Network configuration 在不同的 attachments 間應該保持一致。不過 runtime 會傳遞其他每個 attachment 獨立的參數。</p><ul><li>Container ID: 對應到 Section 2 <code>CNI_CONTAINERID</code> 環境變數</li><li>Namespace: 對應到 <code>CNI_NETNS</code> 環境變數</li><li>Container interface name: 對應到 <code>CNI_IFNAME</code> 環境變數</li><li>Generic Arguments: 對應到 <code>CNI_ARGS</code> 環境變數</li><li>Capability Arguments: </li><li>CNI plugins search path: 對應到 <code>CNI_PATH</code> 環境變數</li></ul><h3 id="Adding-an-attachment"><a href="#Adding-an-attachment" class="headerlink" title="Adding an attachment"></a>Adding an attachment</h3><p>對 configuration 的 <code>plugins</code> 欄位的每個 plugin configuration 執行以下步驟</p><ol><li>根據 <code>type</code> 欄位尋找 CNI plugin 的執行檔，如果找不到則回傳錯誤</li><li>根據 plugin configuration 生成送給 plugin sdtin 的 configuration</li></ol><ul><li>只有第一個執行的 plugin 不會帶 prevResult 欄位，後續執行的 plugin 都會把前一個的 plugin 的結果放在 prevResult</li></ul><ol start="3"><li>執行 plugin 的執行檔。設置 <code>CNI_COMMAND=ADD</code>，提供前面定義的環境變數，以及透過 standard in 傳輸生成出來的 configuration</li><li>如果 plugin 回傳錯誤，中斷執行並回傳錯誤給 caller</li></ol><p>Runtime 必須持久保存最後一個 plugin 的結果，用於 check 和 delete 操作。</p><h3 id="Deleting-an-attachment"><a href="#Deleting-an-attachment" class="headerlink" title="Deleting an attachment"></a>Deleting an attachment</h3><p>刪除 attachment 和添加基本上差不多的，差別是</p><ul><li>plugin 的執行順序是反過來的，從最後一個開始</li><li><code>prevResult</code> 欄永遠是上一次 add 操作時，最後一個 plugin 的結果</li></ul><p>對 configuration 的 <code>plugins</code> 欄位反序的每個 plugin configuration 執行以下步驟</p><ol><li>根據 <code>type</code> 欄位尋找 CNI plugin 的執行檔，如果找不到則回傳錯誤</li><li>根據 plugin configuration 和上次 ADD 執行的 result 生成送給 plugin sdtin 的 configuration</li><li>執行 plugin 的執行檔。設置 <code>CNI_COMMAND=DEL</code>，提供前面定義的環境變數，以及透過 standard in 傳輸生成出來的 configuration</li><li>如果 plugin 回傳錯誤，中斷執行並回傳錯誤給 caller</li></ol><h3 id="Checking-an-attachment"><a href="#Checking-an-attachment" class="headerlink" title="Checking an attachment"></a>Checking an attachment</h3><p>如同 Section 2 所述，Runtime 會透過 CNI plugin 檢查每個 attachment 是否正常運作中。<br>需注意的是 Runtime 必須使用和 add 操作時一致的 attachment parameters</p><p>檢查和添加只有兩個差別</p><ul><li><code>prevResult</code> 欄永遠是上一次 add 操作時，最後一個 plugin 的結果</li><li>如果 network configuation 中 <code>disableCheck</code> 為真，則直接回傳成功</li></ul><p>對 configuration 的 <code>plugins</code> 欄位的每個 plugin configuration 執行以下步驟</p><ol><li>根據 <code>type</code> 欄位尋找 CNI plugin 的執行檔，如果找不到則回傳錯誤</li><li>根據 plugin configuration 和上次 ADD 執行的 result 生成送給 plugin sdtin 的 configuration</li><li>執行 plugin 的執行檔。設置 <code>CNI_COMMAND=CHECK</code>，提供前面定義的環境變數，以及透過 standard in 傳輸生成出來的 configuration</li><li>如果 plugin 回傳錯誤，中斷執行並回傳錯誤給 caller</li></ol><h3 id="Deriving-execution-configuration-from-plugin-configuration"><a href="#Deriving-execution-configuration-from-plugin-configuration" class="headerlink" title="Deriving execution configuration from plugin configuration"></a>Deriving execution configuration from plugin configuration</h3><p>在 add, delete, check 操作時，runtime 必須根據 network configuration 生成出 plugin 可以存取的 execution configuration (基本對應到 plugin configuration)，並填入內容。</p><p>如同 section 2 所述，execution configuration 使用 JSON 格式並透過 stdin 傳給 CNI plugin。</p><ul><li><p>必要的欄位如下:</p><ul><li>cniVersion: 同 network configuraion 中 cniVersion 的值</li><li>name: 同 network configuraion 中 name 的值</li><li>runtimeConfig: runtime 需要和 plugin 可提供的 capabilities 的聯集 (capability 會在後面討論)</li><li>prevResult: CNI plugin 回傳的 Result type 結果</li></ul></li><li><p><code>capabilities</code> 欄位必須被移除</p></li><li><p>其他 plugin configuration 的欄位應該被放入 execution configuration</p></li></ul><h4 id="Deriving-runtimeConfig"><a href="#Deriving-runtimeConfig" class="headerlink" title="Deriving runtimeConfig"></a>Deriving runtimeConfig</h4><p>相對於靜態的 network configuration 來說，runtime 可能會需要根據每個不同的 attachment 產生動態參數。<br>雖然 runtime 可以透過 <code>CNI_ARGS</code> 傳遞動態參數給 CNI plugin，但是我們沒辦法預期說 CNI plugin 會不會接收這個參數。透過 capabilities 欄位，可以明定 plugin 支援的功能，runtime 根據 capabilities 及需求，動態生成設定並填入 <code>runtimeConfig</code>。CNI spec 沒有定義 capability，但是比較通用的 capability 有列舉在另外一份 <a href="https://github.com/containernetworking/cni/blob/main/CONVENTIONS.md#dynamic-plugin-specific-fields-capabilities--runtime-configuration">文件</a>。</p><p>以 kubernetes 常用的 Node port 功能來說，需要 CNI plugin 支援 portMappings 這個 capability。<br>在 section 1 的定義中，plugin configuration 包含了 <code>capabilities</code> 欄位，在這個欄位填入 <code>portMappings</code>，讓 runtime 知道可以透過該 plugin 處理 port mapping。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;myPlugin&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;capabilities&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;portMappings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>Runtime 執行 CNI plugin 時，會根據 <code>capabilities</code> 生成 <code>runtimeConfig</code>，並填入對應的動態參數。 </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;myPlugin&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;runtimeConfig&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;portMappings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <br>      <span class="hljs-punctuation">&#123;</span> <br>        <span class="hljs-attr">&quot;hostPort&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">8080</span><span class="hljs-punctuation">,</span> <br>        <span class="hljs-attr">&quot;containerPort&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">80</span><span class="hljs-punctuation">,</span> <br>        <span class="hljs-attr">&quot;protocol&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;tcp&quot;</span> <br>      <span class="hljs-punctuation">&#125;</span> <br>    <span class="hljs-punctuation">]</span><br>  <span class="hljs-punctuation">&#125;</span><br>  ...<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="Section-4-Plugin-Delegation"><a href="#Section-4-Plugin-Delegation" class="headerlink" title="Section 4: Plugin Delegation"></a>Section 4: Plugin Delegation</h2><p>雖然 CNI 的主要的架構是一系列的 CNI plkugin 依次執行，但這樣的方式有些時候沒辦法滿足 CNI 的需求。CNI plugin 可能會需要將某些功能委託給另外一個 CNI plugin，並存在 plugin 呼叫 plugin 的情況，最常見的案例就是 IP 地址的分配管理。</p><p>通常來說，CNI plugin 應該要指定並維護容器的 IP 地址以及下達必要的 routing rules，雖然由 CNI plugin 自主完成可以讓 CNI plugin 有更大的彈性但是也加重了 CNI plugin 的職責和開發難度，讓不同的 CNI plugin 需要重複開發相同的 IP 地址管理邏輯，因此許多 CNI 將 IP 管理的邏輯委託給另一個獨立的 plugin，讓相關邏輯可以直接被複用。對此除了前面提到的 interface plugin 和 chanined plugin，我們定義了第三類的 plugin - IP Address Management Pligin (IPAM plugin)。</p><p>由主要的 CNI plugin 去呼叫 IPAM plugin，IPAM plugin 判斷網路介面的 IP 地址、gateway、routing rules，並回傳資訊給主要的 CNI plugin 去完成相對應設置。(IPAM plugin 可能會透過 dhcp 之類的 protocl, 儲存在本地的檔案系統資訊或 network configuration 的 ipam section 取得資訊)</p><h3 id="Delegated-Plugin-protocol"><a href="#Delegated-Plugin-protocol" class="headerlink" title="Delegated Plugin protocol"></a>Delegated Plugin protocol</h3><p>和 Runtime 執行 CNI plugin 的方式一樣，delegated plugin 也是透過執行 CNI plugin 可執行程式的方式。主要的 plugin 在 <code>CNI_PATH</code> 路徑下搜尋 CNI plugin。delegated plugin 必須接收和主要 plugin 完全一致的環境變數參數，以及主要 plugin 透過 stdin 接收到的完整 execute configuration。<br>如果執行成功則回傳 0，並透過 stdout 返回 Success result type output。</p><h3 id="Delegated-plugin-execution-procedure"><a href="#Delegated-plugin-execution-procedure" class="headerlink" title="Delegated plugin execution procedure"></a>Delegated plugin execution procedure</h3><ul><li><p>當 CNI plugin 執行 delegated plugin 時:</p><ul><li>在 <code>CNI_PATH</code> 路徑下搜尋 plugin 的可執行程式</li><li>使用 CNI plugin 的環境變數參數和 execute configuration，作為 delegated plugin 的輸入</li><li>確保 delegated plugin 的 stderr 會輸出到 CNI plugin 的 stderr</li></ul></li><li><p>當 plugin 執行 delete 和 check 時，必須執行所有的 delegated plugin，並將 delegated plugin 的錯誤回傳給 runtime</p></li><li><p>當 ADD 失敗時，plugin 應該在回傳錯誤前，先執行 delegated plugin 的 <code>DEL</code></p></li></ul><h2 id="Section-5-Result-Types"><a href="#Section-5-Result-Types" class="headerlink" title="Section 5: Result Types"></a>Section 5: Result Types</h2><ul><li>Plugin 的回傳結果使用 JSON 格式，並有三種<ul><li>Success</li><li>Error</li><li>Version</li></ul></li></ul><h3 id="Success"><a href="#Success" class="headerlink" title="Success"></a>Success</h3><ul><li>如果 plugin 的輸入包含 <code>prevResult</code>，輸出必須包含該欄位的值，並加上該 plugin 對網路修改的資訊，如果該 plugin 沒有任何操作，則該欄位必須保持原輸入內容。</li></ul><p>Success Type Result 的欄位如下</p><ul><li><p>cniVersion: 同輸入的 <code>cniVersion</code> 版本</p></li><li><p>interfaces: 一個該 plugin 建立的 interface 資訊的陣列，包含 host 的 interface。</p><ul><li>name: interface 的名子</li><li>mac: interface 的 mac address</li><li>sandbox: 該介面的網路環境參考，例如 network namespace 的路徑，如果是 host 介面則該欄位為空，容器內的介面該值應為 <code>CNI_NETNS</code></li></ul></li><li><p>ips: 該 plugin 指定的 ip</p><ul><li>address: CIDR 格式的 ip address (e.g. 192.168.1.1&#x2F;24)</li><li>gateway: default gateway (如果存在的話)</li><li>interface: 介面的 index，對應到前述 interfaces 陣列</li></ul></li><li><p>routes: plugin 建立的 routing rules</p><ul><li>dst: route 的目的 (CIDR)</li><li>gw: nexthop 地址</li></ul></li><li><p>dns</p><ul><li>nameservers: DNS server 位置陣列 (ipv4 或 ipv6 格式)</li><li>domain: DNS 搜尋的 local domain</li><li>search (list of strings): 有優先度的 search domain</li><li>options (list of strings): 其他給 dns resolver 的參數</li></ul></li><li><p>Delgated plugin 可能會忽略不需要的欄位</p><ul><li>IPAM 必須回傳一個 abbreviated Success Type result (忽略 interfaces 和 ips 裡面的 interface 欄位)</li></ul></li></ul><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>plugin 回傳的錯誤資訊，欄位有 <code>cniVersion</code>, <code>code</code>, <code>msg</code>, <code>details</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&#123;<br>  &quot;cniVersion&quot;: &quot;1.0.0&quot;,<br>  &quot;code&quot;: 7,<br>  &quot;msg&quot;: &quot;Invalid Configuration&quot;,<br>  &quot;details&quot;: &quot;Network 192.168.0.0/31 too small to allocate from.&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>Error code 0-99 被保留給通用的錯誤，100 以上是 plugin 自定義的錯誤。</p><table><thead><tr><th>Error code</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>不支援的 CNI 版本</td></tr><tr><td>2</td><td>不支援的 network configuration 欄位，error message 會包含不支援的欄位名稱和數值</td></tr><tr><td>3</td><td>未知或不存在的容器，這個錯誤同時代表 runtime 不需要執行 DEL 之類的清理操作</td></tr><tr><td>4</td><td>無效的環境環境變數參數，error message 會包含無效的欄位名稱</td></tr><tr><td>5</td><td>IO 錯誤，例如無法讀取 stdin 的 execute configuration</td></tr><tr><td>6</td><td>解析錯誤，例如無效的 execute configuration JSON 格式</td></tr><tr><td>7</td><td>無效的 network configuration</td></tr><tr><td>11</td><td>稍後在嘗試，存在暫時無法操作的資源，runtime 應該稍後重試</td></tr></tbody></table><ul><li>此外，stderr 也可被用於非 JSON 結構的錯誤訊息，如 log</li></ul><h3 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h3><ul><li>Version Type Result 的欄位如下<ul><li>cniVersion: 同輸入的 <code>cniVersion</code> 版本</li><li>supportedVersions: 一個支援的 CNI 版本陣列</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&#123;<br>    &quot;cniVersion&quot;: &quot;1.0.0&quot;,<br>    &quot;supportedVersions&quot;: [ &quot;0.1.0&quot;, &quot;0.2.0&quot;, &quot;0.3.0&quot;, &quot;0.3.1&quot;, &quot;0.4.0&quot;, &quot;1.0.0&quot; ]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix:"></a>Appendix:</h2><p>在 CNI SPEC 裏面包含了一些 configuration 和執行過程中 plugin 輸入輸出的範例，可以參考 <a href="https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md#appendix-examples">原始文件</a><br>另外還有一份 CNI 的文件 <a href="https://github.com/containernetworking/cni/blob/main/CONVENTIONS.md">CONVENTIONS</a>，描述許多 spec 裡面沒有定義但是許多 plugin 常用的欄位。</p><h2 id="小節"><a href="#小節" class="headerlink" title="小節"></a>小節</h2><p>以上是對 <a href="https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md">CNI spec 1.0.0</a> 的導讀，希望對大家有幫助。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;這次來嘗試寫寫看 spec 導讀，今天要講的是 &lt;a href=&quot;https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md&quot;&gt;Container Network Interface (CNI) Specification&lt;/a&gt;。CNI 是 &lt;a href=&quot;https://cncf.io/&quot;&gt;CNCF&lt;/a&gt; 的一個專案，這個專案包含了今天要講的 CNI SPEC 以及基於這個 SPEC 開發出來 libraries 還有一系列的 CNI plugins。&lt;/p&gt;</summary>
    
    
    
    <category term="Kubernetes" scheme="https://blog.louisif.me/categories/Kubernetes/"/>
    
    
  </entry>
  
  <entry>
    <title>ONOS P4 Switch Pipeconf 開發</title>
    <link href="https://blog.louisif.me/ONOS/ONOS-P4-Switch-Pipeconf-Development/"/>
    <id>https://blog.louisif.me/ONOS/ONOS-P4-Switch-Pipeconf-Development/</id>
    <published>2022-08-27T16:25:46.000Z</published>
    <updated>2022-08-30T07:44:07.557Z</updated>
    
    <content type="html"><![CDATA[<p>這篇文章會介紹一下，在 ONOS 上 P4 相關的模組和功能，以及怎麼開發 ONOS APP 與設置 ONOS，讓 ONOS 可以控制 p4 switch 的 pipeline。</p><span id="more"></span> <h2 id="背景介紹"><a href="#背景介紹" class="headerlink" title="背景介紹"></a>背景介紹</h2><h3 id="P4Runtime"><a href="#P4Runtime" class="headerlink" title="P4Runtime"></a>P4Runtime</h3><p>P4Runtime 是 P4 API Working Group 制定的一套基於 Protobuf 以及 gRPC 的傳輸協定，他可以提供不同的 P4 交換機和不同的 SDN 控制器一套統一的 API 標準，提供控制器直接透過 p4runtime 將編譯出來 p4 pipeline 直接上傳到 p4 switch 上、設置 p4 pipeline 的 table entry 以及接收 packet-in 的封包和 counter 的資訊等功能。</p><h3 id="ONOS-架構"><a href="#ONOS-架構" class="headerlink" title="ONOS 架構"></a>ONOS 架構</h3><p><img src="/ONOS/ONOS-P4-Switch-Pipeconf-Development/ONOS_Architecture.png" alt="ONOS 架構圖"></p><p>ONOS 使用分層架構和介面抽象的方式隱藏了底層交換機和和控制協定的具體內容，讓上層的應用可以用統一的 API 來管理網路的行為，因此上層網路可以用完全相同的方式來控制 Openflow switch 及 P4 switch，也可以不用理會各個 switch table 順序和具體規則的下達方式。</p><h3 id="ONOS-Flow-programmable"><a href="#ONOS-Flow-programmable" class="headerlink" title="ONOS Flow programmable"></a>ONOS Flow programmable</h3><p><img src="/ONOS/ONOS-P4-Switch-Pipeconf-Development/ONOS_FlowRule_Abstract.png" alt="ONOS FlowRule 抽象架構"></p><p>即便是在北向提供給使用者的 API，ONOS 也對其做了很多層級的抽象，讓使用者可以自由決定要使用哪一個層級的 API。</p><p>在 flow rule 的部分，ONOS 大致上提供了三個層級的抽象，分別是 <code>Flow Rule</code>, <code>Flow Objective</code> 及 <code>Intent</code> ，不論在哪一個層級，我們主要都是要操作兩個集合 <code>Selector</code> 和 <code>Treatment</code></p><p><code>Selector</code> 決定了哪些封包受這條 flow rule 管理。一個 <code>Selector</code> 包含了若干個 <code>Criterion</code> ，ONOS 透過 <code>Enum</code> 定義了常用的 Criterion Type，來對應封包的不同欄位，例如 <code>IPV4_SRC</code> , <code>ETH_SRC</code> 等。</p><p><code>Treatment</code> 則是 <code>Instruction</code> 的集合，一個 instruction 通常對應到對封包的某個欄位進行修改，或著指定封包在交換機的 output port。</p><p>三個抽象層積的差別在於這兩個集合套用到的對象，在最高層級的 <code>Intent</code> ，我們操作的對象是整個網路流，除了 <code>Selector</code> 和 <code>Treatment</code>，我們還要定義整個網路流在 SDN 網路的入口 (Ingress Point) 和出口 (Egress Point)，ONOS 核心的 <code>Intent Service</code> 會幫我們把一個 <code>Intent</code> 編譯成多個 <code>FlowObjective</code>。</p><p>由於 <code>Intent</code> 操作的是整個網路流，在這個層級定義 Output port 是沒有意義的，但是由於在 ONOS 使用的 JAVA API 是共通的，所以 intent service 會忽略掉這個 instruction，這個在 ONOS 的實作上是很重要的觀念，對 treatment 裡的 instructions，底層的編譯器只會取他可以處理的 instructions 往更底層送，對於不可以處理的 instructions，有些會有 warnning log，有些會直接跳 exception，更有的會直接忽略，因此如果 selector 和 treatment 的執行結果不符合我們的預期，有可能是有些不支援的 instruction 在轉換成交換機可以懂得規則的過程中被忽略的。</p><p><code>FlowObjective</code> 操作的對象是一台網路設備 (通常是一台交換機)，同樣我們定義一個 <code>Selector</code> 和 <code>Treatment</code> ，告訴這台交換機我們要處理哪些封包和怎麼處理。</p><p>最底下到了 Flow Rule 這個層級，Flow rule 這個層級對象是交換機上的一張 table，因此他加入了 table id 這個欄位。一個 <code>FlowObjective</code> 可能會包含多個不同的 instruction，例如我們要修改封包的 mac address，修改 ip 的 ttl 欄位，同時也要決定這個封包的 output port，這些 instruction 在 flow objective 層級可以包含在一個 treatment 內，但是在實際的交換機上這些 instruction 可能分別屬於不同的 table，因此一個 flow objective 會需要對應到一條或多條得 flow rule，這依據底下交換機的不同、傳輸協定的不同而不同，因此 ONOS 引入了 <code>Pipeliner</code> ，Driver 可以實作 <code>Pipeliner</code> 的介面，讓 ONOS 知道如何把 flow objective 轉換成 flow rules。</p><h3 id="P4-in-ONOS"><a href="#P4-in-ONOS" class="headerlink" title="P4 in ONOS"></a>P4 in ONOS</h3><p><img src="/ONOS/ONOS-P4-Switch-Pipeconf-Development/ONOS_P4_Architecture.png" alt="ONOS P4 南向介面架構"></p><p>上圖是 p4 在 ONOS 南向架構上的組件</p><p>在 Protocol layer 由 <code>P4Runtime</code> 組件實作 p4runtime procotol，維護 switch 的連線和具體的 gRPC&#x2F;Protobuf 傳輸內容</p><p>接著是 Driver layer，不同的 p4 switch 在 pipeline 的結構等方面存在差異，因此在 ONOS 設定交換機資訊時要根據不同的 Switch 選擇 driver</p><ul><li>如果是 bmv2 switch 使用 <code>org.onosproject.bmv2</code>，如果是 tofino 交換機使用 <code>org.onosproject.barefoot</code></li></ul><p>最上面是 ONOS 核心，這邊有 translation services 和 pipeconf 架構。p4 交換機的特色是能透過 p4lang 定義出完全不同的 pipeline，在使用 ONOS 控制 p4 switch 的時候，我們就需要針對 pipeline 定義註冊 <code>pipeconf</code>，ONOS 核心可以調用 pipeconf 將 flow objective 或 flow rule 的 flow rule 轉換成真正可以下達到 p4 pipeline table 上的 entry。<br>在 ONOS 核心定義的這套 pipeconf 及轉換架構被稱之為 Pipeline Independent (PI) framework，因此 ONOS 相關的 class 和 interface 都會有一個 PI 的前綴。</p><p><img src="/ONOS/ONOS-P4-Switch-Pipeconf-Development/P4_APP_Compare.png" alt="P4 FlowRule 設置流程"></p><p>另外就要提到 Pipeline-agnostic APP 和 Pipeline-aware APP 的差別，這邊指的都是北向介面上面處理網路邏輯的 APP，差別在於 Pipeline-agnostic app 完全不考慮底下的 pipeline，因此通常操作的是 flow objective，而 pipeline aware app 必須知道底層 pipeline 的架構，直接產出特定的 flow rule。</p><p>開發 Pipeline-agnostic APP 的好處是他足夠抽象因此可以應用在各種不同的交換機和網路，但是我們就需要額外實作 pipeliner 等編譯器來做轉換，因此直接如果只針對單一 pipeline 的情況下，直接開發 pipeline aware app 會比較簡單。</p><h2 id="Pipeconf-開發"><a href="#Pipeconf-開發" class="headerlink" title="Pipeconf 開發"></a>Pipeconf 開發</h2><p>在使用 ONOS 控制 p4 switch 時，最基本要做的就是撰寫 pipeline 對應的 pipeconf。一個完整的 Pipeconf 會包含</p><ul><li><p>從 p4 compiler 拿到 pipeline 資訊檔案，p4info, bmv2 json, Tofino binary….</p></li><li><p>PipeconfLoader: 一個 pipeconf 的進入點，向 PiPipeconfService 註冊一個或多個 pipeconf，定義 pipeconf 的 id, 對應的 interpreter, pipeliner, p4info 檔案路徑等資訊。</p></li><li><p>Interpreter: 主要負責兩件事</p><ul><li>提供 ONOS 核心資訊並協助將 common flow rule 轉換成 protocol independent flow rule，包含了 table id 的 mapping, 欄位名稱和數值的轉換等</li><li>處理 packet-in&#x2F;packet-out 的封包，當封包從 p4 switch packet-in 到 controller 時，會把 metadata (input port 等資訊) 當作 packet 的一個 header 附加在 packet 中，一起送到 controller，pipeconf 需要解析封包，將封包資訊提取出來。當封包 packet-out 時，同樣需要 metadata 轉換成 pipeline 定義的 packet-out header，附加在封包內送至交換機，pipeline parser 才能重新將資訊解析出來處理。</li></ul></li><li><p>Pipeliner: 負責將 flow objective 轉換成 flow rule</p></li></ul><p>但是 Interpreter 和 Pipeliner 的功能是不一定要實作的，如果對應的功能沒有被實作，那北向的 APP 就只能呼叫比較底層的 API 而無法調動 flow objective 等功能。</p><h3 id="開發目標"><a href="#開發目標" class="headerlink" title="開發目標"></a>開發目標</h3><p>下面會用一個非常簡單的 p4 pipeline 作為範例，我們預期要實作一個基本的 Layer 2 switch pipeline，使 ProxyARP APP 和 Reactive Forwarding APP 能夠正常的運作。(使用 bmv2 和 ONOS v2.7.0 開發)</p><h3 id="建立-ONOS-APP"><a href="#建立-ONOS-APP" class="headerlink" title="建立 ONOS APP"></a>建立 ONOS APP</h3><p>跟任何其他 ONOS 模組一樣，pipeconf 可以作為一個獨立的 ONOS APP 開發，再安裝到 ONOS 上，所以首先建立我們的 <code>simepleswitch</code> APP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">onos-create-app<br>Define value for property &#x27;groupId&#x27;: me.louisif.pipelines<br>Define value for property &#x27;artifactId&#x27;: simpleswitch<br>Define value for property &#x27;version&#x27; 1.0-SNAPSHOT: :<br>Define value for property &#x27;package&#x27; me.louisif: : me.louisif.pipelines.simpleswitch<br></code></pre></td></tr></table></figure><h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><p>在 pipeconf 的開發中，使用到 p4 相關的 api 並沒有被包含在 onos 標準 api 內，需要額外加入 p4runtime-model 這個 dependency。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.onosproject<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>onos-protocols-p4runtime-model<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;onos.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>另外可以在 onos 的 dependency app 列表內加入 pipeline 對應的 driver，這樣啟動 pipeconf 時就會自動啟用相關的 driver app，而不用事前手動啟動。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">onos.app.requires</span>&gt;</span>org.onosproject.drivers.bmv2<span class="hljs-tag">&lt;/<span class="hljs-name">onos.app.requires</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="P4-撰寫"><a href="#P4-撰寫" class="headerlink" title="P4 撰寫"></a>P4 撰寫</h3><p>接著撰寫我們的 p4 檔案，路徑是 src&#x2F;main&#x2F;resource&#x2F;simpleswitch.p4。resource 資料夾在編譯的時候會被附加到編譯出來的 oar 裡面，所以可以直接在 ONOS 執行的時候存取到編譯出來的 p4info 等檔案。完整的檔案在 <a href="https://github.com/gamerslouis/onos-p4-tutorial">github</a> 上。</p><p>在 simpleswitch 的 ingress pipeline 內只包含一張 table0，用於 L2 的 packet forwarding，使用 send 這個 action 來將封包丟到指定的 output port，在 bmv2 switch 會定義一個 cpu port，當 egress_port 為該 port number 時，封包就會被送至 ONOS，因此 send_to_cpu 這個 action 只單純做 set egress port 這個動作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c">control <span class="hljs-title function_">table0_control</span><span class="hljs-params">(inout <span class="hljs-type">headers_t</span> hdr,</span><br><span class="hljs-params">                inout <span class="hljs-type">local_metadata_t</span> local_metadata,</span><br><span class="hljs-params">                inout <span class="hljs-type">standard_metadata_t</span> standard_metadata)</span> &#123;<br>    action <span class="hljs-title function_">send</span><span class="hljs-params">(<span class="hljs-type">port_t</span> port)</span> &#123;<br>        standard_metadata.egress_spec = port;<br>    &#125;<br><br>    action <span class="hljs-title function_">send_to_cpu</span><span class="hljs-params">()</span> &#123;<br>        standard_metadata.egress_spec = CPU_PORT;<br>    &#125;<br><br>    action <span class="hljs-title function_">drop</span><span class="hljs-params">()</span> &#123;<br>        mark_to_drop (standard_metadata);<br>    &#125;<br><br>    table table0 &#123;<br>        key = &#123;<br>            standard_metadata.ingress_port : ternary;<br>            hdr.ethernet.src_addr          : ternary;<br>            hdr.ethernet.dst_addr          : ternary;<br>            hdr.ethernet.ether_type        : ternary;<br>        &#125;<br><br>        actions = &#123;<br>            send;<br>            send_to_cpu;<br>            drop;<br>        &#125;<br>        default_action = drop;<br>        size = <span class="hljs-number">512</span>;<br>    &#125;<br><br>    apply &#123;<br>        table0.apply ();<br>    &#125;<br>&#125;<br>control <span class="hljs-title function_">MyIngress</span><span class="hljs-params">(inout <span class="hljs-type">headers_t</span> hdr,</span><br><span class="hljs-params">                  inout <span class="hljs-type">local_metadata_t</span> meta,</span><br><span class="hljs-params">                  inout <span class="hljs-type">standard_metadata_t</span> standard_metadata)</span> &#123;<br>    apply &#123;<br>        <span class="hljs-comment">// 這個後面在介紹 </span><br>        <span class="hljs-comment">//if (standard_metadata.ingress_port == CPU_PORT) &#123;</span><br>        <span class="hljs-comment">//    standard_metadata.egress_spec = hdr.packet_out.egress_port;</span><br>        <span class="hljs-comment">//    hdr.packet_out.setInvalid ();</span><br>        <span class="hljs-comment">//    exit;</span><br>        <span class="hljs-comment">// &#125; else &#123;</span><br>            table0_control.apply (hdr, meta, standard_metadata);<br>        <span class="hljs-comment">// &#125;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="P4-編譯"><a href="#P4-編譯" class="headerlink" title="P4 編譯"></a>P4 編譯</h3><p>編譯 bmv2 pipeline 可以直接複製 ONOS 內建的 basic pipeline 使用的 <a href="https://github.com/opennetworkinglab/onos/tree/master/pipelines/basic/src/main/resources">編譯腳本</a>，將 Makefile 和 bmv2-compile.sh 這兩個檔案複製到 resources 資料夾下，然後修改 Makefile 把 basic 改成 simpleswitch，並刪除 int pipeline。可以簡單下 <code>make</code> 來完成 pipeline 的編譯。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs makefile">ROOT_DIR:=<span class="hljs-variable">$(<span class="hljs-built_in">shell</span> dirname $(<span class="hljs-built_in">realpath</span> $(<span class="hljs-built_in">firstword</span> <span class="hljs-variable">$(MAKEFILE_LIST)</span>)</span>))/..<br><br><span class="hljs-section">all: p4 constants</span><br><br><span class="hljs-section">p4: simpleswitch.p4</span><br>        @./bmv2-compile.sh <span class="hljs-string">&quot;simpleswitch&quot;</span> <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-section">constants:</span><br>        docker run -v <span class="hljs-variable">$(ONOS_ROOT)</span>:/onos -w /onos/tools/dev/bin \<br>                -v <span class="hljs-variable">$(ROOT_DIR)</span>:/source \<br>                --entrypoint ./onos-gen-p4-constants opennetworking/p4mn:stable \<br>                -o /source/java/me/louisif/pipelines/simpleswitch/SimpleswitchConstants.java \<br>                simpleswitch /source/resources/p4c-out/bmv2/simpleswitch_p4info.txt<br><br><span class="hljs-section">clean:</span><br>        rm -rf p4c-out/bmv2/*<br></code></pre></td></tr></table></figure><p>這個 makefile 主要分為兩個部分。p4 會呼叫 bmv2-compile，編譯出 bmv2 的 p4info 和描述 pipeline 的 json 檔案。constants 則會使用 p4mn 這個 container 生成出一個 SimpleswitchConstants.java 的檔案，這個檔案會把 pipeline 所有 table 名稱、欄位、action 名稱列舉出來，方便 pipeconf 的程式碼直接調用，以 table0 來說，它的完整名稱為 <code>MyIngress.table0_control.table0</code> ，可以使用 MY_INGRESS_TABLE0_CONTROL_TABLE0 變數來代表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">PiTableId</span> <span class="hljs-variable">MY_INGRESS_TABLE0_CONTROL_TABLE0</span> <span class="hljs-operator">=</span><br>            PiTableId.of (<span class="hljs-string">&quot;MyIngress.table0_control.table0&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="最小可執行-Pipeconf"><a href="#最小可執行-Pipeconf" class="headerlink" title="最小可執行 Pipeconf"></a>最小可執行 Pipeconf</h2><h3 id="撰寫-PipeconfLoader"><a href="#撰寫-PipeconfLoader" class="headerlink" title="撰寫 PipeconfLoader"></a>撰寫 PipeconfLoader</h3><p>接著我們要先寫一個最小可以動的 pipeconf，只包含 PipeconfLoader.java 這個檔案，路徑是 src&#x2F;main&#x2F;java&#x2F;me&#x2F;louisif&#x2F;simpleswitch&#x2F;PipeconfLoader.java，前文提到 PipeconfLoader 的工作是向 <code>PipeconfService</code> 註冊 pipeconf 的資訊，因此我們幫 PipeconfLoader 加上 <code>Component</code> 的 Annotation，讓 activate function 在 APP 啟動時被呼叫，接著在 activate function 裡面去註冊 pipeconf。</p><p>以我們的例子而言，我們使用的是 bmv2 的 pipeline，所以我們可以這樣寫</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">URL</span> <span class="hljs-variable">jsonUrl</span> <span class="hljs-operator">=</span> PipeconfLoader.class.getResource (<span class="hljs-string">&quot;/p4c-out/bmv2/simpleswitch.json&quot;</span>);<br><span class="hljs-keyword">final</span> <span class="hljs-type">URL</span> <span class="hljs-variable">p4InfoUrl</span> <span class="hljs-operator">=</span> PipeconfLoader.class.getResource (<span class="hljs-string">&quot;/p4c-out/bmv2/simpleswitch_p4info.txt&quot;</span>);<br><br><span class="hljs-type">PiPipeconf</span> <span class="hljs-variable">pipeconf</span> <span class="hljs-operator">=</span> DefaultPiPipeconf.builder ()<br>        .withId (PIPECONF_ID)<br>        .withPipelineModel (P4InfoParser.parse (p4InfoUrl))<br>        .addExtension (P4_INFO_TEXT, p4InfoUrl)<br>        .addExtension (BMV2_JSON, jsonUrl)<br>        .build ();<br>piPipeconfService.register (pipeconf);<br></code></pre></td></tr></table></figure><p>檔案路徑要填寫相對於 resource 這個資料夾的路徑，另外 <code>addExtension</code> 的內容會根據 switch 的不同而不同，如果我們今天使用的是 tonifo 的 pipeline 那就要改成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">URL</span> <span class="hljs-variable">binUrl</span> <span class="hljs-operator">=</span> PipeconfLoader.class.getResource (<span class="hljs-string">&quot;/p4c-out/tofino.bin&quot;</span>);<br><span class="hljs-keyword">final</span> <span class="hljs-type">URL</span> <span class="hljs-variable">p4InfoUrl</span> <span class="hljs-operator">=</span> PipeconfLoader.class.getResource (<span class="hljs-string">&quot;/p4c-out/p4info.txt&quot;</span>);<br><span class="hljs-keyword">final</span> <span class="hljs-type">URL</span> <span class="hljs-variable">contextJsonUrl</span> <span class="hljs-operator">=</span> PipeconfLoader.class.getResource (<span class="hljs-string">&quot;/p4c-out/context.json&quot;</span>);<br><br>DefaultPiPipeconf.builder ()<br>                .withId (PIPECONF_ID)<br>                .withPipelineModel (parseP4Info (p4InfoUrl))<br>.addExtension (P4_INFO_TEXT, p4InfoUrl)<br>                .addExtension (TOFINO_BIN, binUrl)<br>                .addExtension (TOFINO_CONTEXT_JSON, contextJsonUrl)<br>                .build ();<br>piPipeconfService.register (pipeconf);<br></code></pre></td></tr></table></figure><h3 id="測試"><a href="#測試" class="headerlink" title="測試"></a>測試</h3><p>完成 PipeconfLoader.java 就構成了一個可以運作的 pipeconf，為了測試我們使用 opennetworking&#x2F;p4mn 這個 container 來實驗，p4mn 是一個 mininet 的 docker image，可以很簡單的啟動一個 mininet 的測試拓譜，並使用 bmv2 switch 取代 mininet 原本使用的 openflow switch。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">docker run -v /tmp/p4mn:/tmp --privileged --rm -it -p <span class="hljs-number">50001</span>:<span class="hljs-number">50001</span> opennetworking/p4mn:stable<br></code></pre></td></tr></table></figure><p>使用這個指令可以啟動一個包含一個叫做 bmv2-s1 的 bmv2 switch 和兩個 host</p><p><img src="/ONOS/ONOS-P4-Switch-Pipeconf-Development/p4mn_topo.png" alt="P4mn 拓譜"></p><p>同時會生成一個 onos 的 netcfg 檔案，路徑 &#x2F;tmp&#x2F;p4mn&#x2F;bmv2-s1-netcfg.json</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>    <span class="hljs-string">&quot;devices&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;device:bmv2:s1&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;ports&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;1&quot;</span>: &#123;<br>                    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;s1-eth1&quot;</span>,<br>                    <span class="hljs-string">&quot;speed&quot;</span>: <span class="hljs-number">10000</span>,<br>                    <span class="hljs-string">&quot;enabled&quot;</span>: <span class="hljs-literal">true</span>,<br>                    <span class="hljs-string">&quot;number&quot;</span>: <span class="hljs-number">1</span>,<br>                    <span class="hljs-string">&quot;removed&quot;</span>: <span class="hljs-literal">false</span>,<br>                    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;copper&quot;</span><br>                &#125;,<br>                <span class="hljs-string">&quot;2&quot;</span>: &#123;<br>                    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;s1-eth2&quot;</span>,<br>                    <span class="hljs-string">&quot;speed&quot;</span>: <span class="hljs-number">10000</span>,<br>                    <span class="hljs-string">&quot;enabled&quot;</span>: <span class="hljs-literal">true</span>,<br>                    <span class="hljs-string">&quot;number&quot;</span>: <span class="hljs-number">2</span>,<br>                    <span class="hljs-string">&quot;removed&quot;</span>: <span class="hljs-literal">false</span>,<br>                    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;copper&quot;</span><br>                &#125;<br>            &#125;,<br>            <span class="hljs-string">&quot;basic&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;managementAddress&quot;</span>: <span class="hljs-string">&quot;grpc://localhost:50001?device_id=1&quot;</span>,<br>                <span class="hljs-string">&quot;driver&quot;</span>: <span class="hljs-string">&quot;bmv2&quot;</span>,<br>                <span class="hljs-string">&quot;pipeconf&quot;</span>: <span class="hljs-string">&quot;me.louisif.pipelines.simpleswitch&quot;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>這個檔案包含了 ONOS P4 需要的所有資訊，主要分為兩個部分，ports 定義了這個交換機所有的 port 資訊。basic 部分，managementAddress 是 ONOS 用來使用 p4runtime 連線到 switch 的路徑，pipeconf 指定了這個 switch 使用的 pipeconf，預設會是 org.onosproject.pipelines.basic，在我們的範例中需要改為 me.louisif.pipelines.simpleswitch。</p><p>只要將 me.louisif.pipelines.simpleswitch 的 app 啟用，並上傳 bmv2-s1-netcfg.json，ONOS 就可以成功連線到這個 bmv2 switch，並正常提供北向的 APP 服務了。</p><h3 id="如何下-flow-rule"><a href="#如何下-flow-rule" class="headerlink" title="如何下 flow rule"></a>如何下 flow rule</h3><p>完成 pipeconf 後，我們就可以透過下 flow rule 的方式來讓 switch 工作了，為了要讓 h1 和 h2 能夠互相溝通，最簡單的方法就是將所有 port 1 進來的封包送到 port 2、所有從 port 2 進來的封包送到 port 1。</p><p>為此我們需要兩條 table0 的 entry，分別是</p><ul><li>standard_metadata.ingress_port &#x3D;&#x3D; 1 (mask 0x1ff) → send port&#x3D;2</li><li>standard_metadata.ingress_port &#x3D;&#x3D; 2 (mask 0x1ff) → send port&#x3D;1</li></ul><p>由於 standard_metadata.ingress_port 這個 key 是 ternary，因此我們需要包含 mask, port 這個 type 的長度是 9 bits，因為要完全一致，所以 mask 是 0x1ff。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> PiCriterion.<span class="hljs-type">Builder</span> <span class="hljs-variable">criterionBuilder</span> <span class="hljs-operator">=</span> PiCriterion.builder ()<br>                .matchTernary (PiMatchFieldId.of (<span class="hljs-string">&quot;standard_metadata.ingress_port&quot;</span>), inPortNumber.toLong (), <span class="hljs-number">0x1ff</span>);<br><span class="hljs-keyword">final</span> <span class="hljs-type">PiAction</span> <span class="hljs-variable">piAction</span> <span class="hljs-operator">=</span> PiAction.builder ().withId (PiActionId.of (<span class="hljs-string">&quot;MyIngress.table0_control.send&quot;</span>))<br>        .withParameter (<span class="hljs-keyword">new</span> <span class="hljs-title class_">PiActionParam</span>(PiActionParamId.of (<span class="hljs-string">&quot;port&quot;</span>), outPortNumber.toLong ()))<br>        .build ();<br><span class="hljs-keyword">final</span> <span class="hljs-type">FlowRule</span> <span class="hljs-variable">flowRule</span> <span class="hljs-operator">=</span> DefaultFlowRule.builder ()<br>        .fromApp (coreService.getAppId (APP_NAME))<br>        .forDevice (deviceId)<br>        .forTable (PiTableId.of (<span class="hljs-string">&quot;MyIngress.table0_control.table0&quot;</span>)).makePermanent ().withPriority (<span class="hljs-number">65535</span>)<br>        .withSelector (DefaultTrafficSelector.builder ().matchPi (criterionBuilder.build ()).build ())<br>        .withTreatment (DefaultTrafficTreatment.builder ().piTableAction (piAction).build ()).build ();<br>flowRuleService.applyFlowRules (flowRule);<br></code></pre></td></tr></table></figure><p>我們可以透過這樣的方式來下達第一條 table entry，可以發現和平常的 flow entry 不一樣的地方是 table id 使用的是 PiTableId 這個 type，並指定了 table0 的完整 id <code>MyIngress.table0_control.table0</code>，另外 <code>Selector</code> 和 <code>Treatment</code> 分別使用了 matchPi 和 piTableAction 這兩個特別的函數。</p><p>我們這邊將只使用 PiTableId, PiCriterion 和 PiAction 定義的 flow rule 稱之為 PI flow rule，PI flow rule 是 onos 的 p4runtime 可以直接處理的 flow rule，所有的欄位名稱都唯一對應到 p4 pipeline 的某個欄位，前面提到這些 PiTableId, PiMatchFieldId 等都會在 SimpleswitchConstants.java 內被定義，因此可以直接使用來縮短程式碼長度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> me.louisif.pipelines.simpleswitch.SimpleswitchConstants.*;<br><br><span class="hljs-keyword">final</span> PiCriterion.<span class="hljs-type">Builder</span> <span class="hljs-variable">criterionBuilder</span> <span class="hljs-operator">=</span> PiCriterion.builder ()<br>                .matchTernary (INGRESS_PORT, inPortNumber.toLong (), <span class="hljs-number">0x1ff</span>);<br><span class="hljs-keyword">final</span> <span class="hljs-type">PiAction</span> <span class="hljs-variable">piAction</span> <span class="hljs-operator">=</span> PiAction.builder ().withId (MY_INGRESS_TABLE0_CONTROL_SEND)<br>        .withParameter (PORT, outPortNumber.toLong ()))<br>        .build ();<br><span class="hljs-keyword">final</span> <span class="hljs-type">FlowRule</span> <span class="hljs-variable">flowRule</span> <span class="hljs-operator">=</span> DefaultFlowRule.builder ()<br>        .fromApp (coreService.getAppId (APP_NAME))<br>        .forDevice (deviceId)<br>        .forTable (MY_INGRESS_TABLE0_CONTROL_TABLE0).makePermanent ().withPriority (<span class="hljs-number">65535</span>)<br>        .withSelector (DefaultTrafficSelector.builder ().matchPi (criterionBuilder.build ()).build ())<br>        .withTreatment (DefaultTrafficTreatment.builder ().piTableAction (piAction).build ()).build ();<br>flowRuleService.applyFlowRules (flowRule);<br></code></pre></td></tr></table></figure><blockquote><p>在範例程式碼裡面包含了簡單的 cli 指令實作，因此可以在 ONOS CLI 使用 <code>add-pi-flow-rule &lt;device id&gt; &lt;input port&gt; &lt;output port&gt;</code> 的方式來下達上面的 flow rule。詳情可以 <a href="https://github.com/gamerslouis/onos-p4-tutorial/blob/master/simpleswitch/src/main/java/me/louisif/pipelines/simpleswitch/cli/AddPiFlowRule.java">參考檔案</a>。</p></blockquote><p>當然這樣編寫出來的 flow rule 會產生一個問題，如果相同的 pipeline，我們希望能從 bmv2 移植到 tonifo 上面去使用，由於欄位的名稱會存在差異，因此所有下達 flow rule 的 APP 都需要重新寫，顯然這樣不是一個很好的做法，增加了程式碼維護上的困難，因此 ONOS 加入前面提到的 Interpreter 還有 translator 機制，下一節會介紹如何為 pipeline 編寫 Interpreter 還有用比較通用的方法來下 flow rule，在完成 interpreter 後上述的 flow rule，可以用下面這個我們比較熟悉的方法來下達。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TABLE0_TABLE_ID</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">FlowRule</span> <span class="hljs-variable">flowRule</span> <span class="hljs-operator">=</span> DefaultFlowRule.builder ()<br>  .fromApp (coreService.getAppId (APP_NAME))<br>  .forDevice (deviceId)<br>  .forTable (TABLE0_TABLE_ID).makePermanent ().withPriority (<span class="hljs-number">65535</span>)<br>  .withSelector (DefaultTrafficSelector.builder ().matchInPort (inPortNumber).build ())<br>  .withTreatment (DefaultTrafficTreatment.builder ().setOutput (outPortNumber).build ())<br>  .build ();<br><br>flowRuleService.applyFlowRules (flowRule);<br></code></pre></td></tr></table></figure><h2 id="撰寫-Interpreter"><a href="#撰寫-Interpreter" class="headerlink" title="撰寫 Interpreter"></a>撰寫 Interpreter</h2><p>在前一節我們完成了基本的 pipeconf 註冊，並使用 PI flow rule 的方式來控制交換機，但是直接使用 PI flow rule 會降低 APP 的彈性，使移植到不同 pipeline 的困難度提高。另外 SDN 的一個特色是可以使用 packet-in&#x2F;packet-out 的方式來讓 controller 即時性的處理封包，因此本結會介紹如何實作 Interpreter 來提供 packet-in&#x2F;packet-out，以及 flow rule translation 的功能。</p><p>要提供一個 pipeline interpreter，我們需要實作 PiPipelineInterpreter 這個介面，要注意的是 Interpreter class 需要繼承 AbstractHandlerBehaviour，然後再 PipeconfLoader 去指定這個實作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleSwitchInterpreterImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractHandlerBehaviour</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PiPipelineInterpreter</span> &#123;<br>&#125;<br><br><span class="hljs-type">PiPipeconf</span> <span class="hljs-variable">pipeconf</span> <span class="hljs-operator">=</span> DefaultPiPipeconf.builder ()<br>        .withId (PIPECONF_ID)<br>        .withPipelineModel (P4InfoParser.parse (p4InfoUrl))<br>.addBehaviour (PiPipelineInterpreter.class, SimpleSwitchInterpreterImpl.class)<br>        .addExtension (P4_INFO_TEXT, p4InfoUrl)<br>        .addExtension (BMV2_JSON, jsonUrl)<br>        .build ();<br></code></pre></td></tr></table></figure><p>當一條 flow rule 被加入到 ONOS 時，PI framework 會將其翻譯成 PI flow rule，也就是將非 PI * 的欄位轉換成 PI flow rule 的欄位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">FlowRule</span> <span class="hljs-variable">flowRule</span> <span class="hljs-operator">=</span> DefaultFlowRule.builder ()<br>  .forTable (<span class="hljs-number">0</span>)<br>.withSelector (DefaultTrafficSelector.builder ().matchInPort (inPortNumber).build ())<br>  .withTreatment (DefaultTrafficTreatment.builder ().setOutput (outPortNumber).build ())<br>  .build ();<br><br></code></pre></td></tr></table></figure><h3 id="Table-Id-translation"><a href="#Table-Id-translation" class="headerlink" title="Table Id translation"></a>Table Id translation</h3><p>以前面提到的 port 1 送到 port 2 的 flow rule 來示範，我們需要把 table id 0，轉換成 <code>PiTableId.of (&quot;MyIngress.table0_control.table0&quot;)</code> ，這對應到 Interpreter 的 mapFlowRuleTableId 函數，我們可以定義一個 map 來記錄，table index 跟 Pi table id 之間的關係，然後實作 mapFlowRuleTableId。這邊的 id 0 並不具有特定的意義，只是單純我們 interpreter 定義的 table index，因此當 APP 使用時，需要知道這個 index 對應到的 table 具體是什麼功能，當然通常我們會再加上一層 pipeliner，透過 flow objective 來隱藏 table id 的細節。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Integer, PiTableId&gt; TABLE_MAP = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImmutableMap</span>.Builder&lt;Integer, PiTableId&gt;()<br>    .put (<span class="hljs-number">0</span>, MY_INGRESS_TABLE0_CONTROL_TABLE0)<br>    .build ();<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Optional&lt;PiTableId&gt; <span class="hljs-title function_">mapFlowRuleTableId</span><span class="hljs-params">(<span class="hljs-type">int</span> flowRuleTableId)</span> &#123;<br>    <span class="hljs-keyword">return</span> Optional.ofNullable (TABLE_MAP.get (flowRuleTableId));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Selector-Translation"><a href="#Selector-Translation" class="headerlink" title="Selector Translation"></a>Selector Translation</h3><p>我們通常使用 <code>DefaultTrafficSelector.builder</code> 來定義 Selector。 <code>matchInPort</code> 會在 selector 內加入一個 <code>PortCriterion</code> ，他的 criterion tpye 是 <code>Criterion.Type.IN_PORT</code> ，為此 Interpreter 需要根據 Criterion type，將其轉換成 p4 table 對應的 key，同樣我們使用 map 的方式來維護其關係。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Criterion.Type, PiMatchFieldId&gt; CRITERION_MAP =<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">ImmutableMap</span>.Builder&lt;Criterion.Type, PiMatchFieldId&gt;()<br>          .put (Criterion.Type.IN_PORT, HDR_STANDARD_METADATA_INGRESS_PORT)<br>          .put (Criterion.Type.ETH_SRC, HDR_HDR_ETHERNET_SRC_ADDR)<br>          .put (Criterion.Type.ETH_DST, HDR_HDR_ETHERNET_DST_ADDR)<br>          .put (Criterion.Type.ETH_TYPE, HDR_HDR_ETHERNET_ETHER_TYPE)<br>          .build ();<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Optional&lt;PiMatchFieldId&gt; <span class="hljs-title function_">mapCriterionType</span><span class="hljs-params">(Criterion.Type type)</span> &#123;<br>    <span class="hljs-keyword">return</span> Optional.ofNullable (CRITERION_MAP.get (type));<br>&#125;<br></code></pre></td></tr></table></figure><p>可能有些人會有些疑惑說，p4 table key 可能會是 exact 或是 ternary，那 ONOS 要怎麼把 <code>matchInPort</code> 轉換成 ternary mask 0x1ff </p><p>前面提到在註冊 pipeconf 時，我們透過 <code>.withPipelineModel (P4InfoParser.parse (p4InfoUrl))</code> 載入 p4info (在 ONOS 內稱之為 <code>PiPipelineModel</code>)，每個 key 具體的類型和資料長度會包含在 p4info 內，PI framework 在轉換時會根據不同 criterion type 和 key type 的不同和需求自動做轉換。</p><h3 id="Treatment-Translation"><a href="#Treatment-Translation" class="headerlink" title="Treatment Translation"></a>Treatment Translation</h3><p>不像 table id 和 criterion，在 p4 內，每個 action 是一個可帶參數的 function，和 ONOS 定義的 treatment 不存在簡單的對應關係，因此 interpreter 定義了 mapTreatment，輸入是 treatment 和 table id，輸出是 PiAction，讓 interpreter 完整的處理整個 treatment。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> PiAction <span class="hljs-title function_">mapTreatment</span><span class="hljs-params">(TrafficTreatment treatment, PiTableId piTableId)</span> <span class="hljs-keyword">throws</span> PiInterpreterException &#123;<br>    <span class="hljs-comment">// 檢查 table id 是否有效，由於只有 table0 一張 table，因此這邊直接檢查 table id 是不是 table 0</span><br><span class="hljs-keyword">if</span> (!piTableId.equals (MY_INGRESS_TABLE0_CONTROL_TABLE0)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PiInterpreterException</span>(<span class="hljs-string">&quot;Unsupported table id: &quot;</span> + piTableId);<br>    &#125;<br>    <span class="hljs-comment">// 我們的 pipeline 只支援 set output port 一個 instruction</span><br>    <span class="hljs-keyword">if</span> (treatment.allInstructions ().size () != <span class="hljs-number">1</span> ||<br>            !treatment.allInstructions ().get (<span class="hljs-number">0</span>).type ().equals (Instruction.Type.OUTPUT)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PiInterpreterException</span>(<span class="hljs-string">&quot;Only output instruction is supported&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-type">PortNumber</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> ((Instructions.OutputInstruction) treatment.allInstructions ().get (<span class="hljs-number">0</span>)).port ();<br>    <br>    <span class="hljs-comment">// 像 controller、flooding 這些特別的 port，稱之為 Logical port</span><br>    <span class="hljs-keyword">if</span> (port.isLogical ()) &#123;<br>        <span class="hljs-keyword">if</span> (port.exactlyEquals (PortNumber.CONTROLLER)) &#123;<br>            <span class="hljs-comment">// 我們支援使用 send_to_controller 這個 action 將封包送到 ONOS</span><br>            <span class="hljs-keyword">return</span> PiAction.builder ().withId (MY_INGRESS_TABLE0_CONTROL_SEND_TO_CPU)<br>                    .build ();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PiInterpreterException</span>(<span class="hljs-string">&quot;Unsupported logical port: &quot;</span> + port);<br>        &#125;<br>    &#125;<br>    <br>    一般的使用用 send 這個 action 來傳送封包 < br>    <span class="hljs-keyword">return</span> PiAction.builder ().withId (MY_INGRESS_TABLE0_CONTROL_SEND)<br>            .withParameter (<span class="hljs-keyword">new</span> <span class="hljs-title class_">PiActionParam</span>(PORT, port.toLong ()))<br>            .build ();<br>&#125;<br></code></pre></td></tr></table></figure><p>到此我們已經完成了 flow rule 的轉換，可以使用 ONOS 標準的 flow rule 來操作 pipeline 了。</p><blockquote><p>如果希望對轉換機制有更詳細的瞭解可以查看 <a href="https://github.com/opennetworkinglab/onos/blob/master/core/net/src/main/java/org/onosproject/net/pi/impl/PiFlowRuleTranslatorImpl.java">ONOS 原始碼</a></p></blockquote><h3 id="Packet-in-x2F-Packet-out"><a href="#Packet-in-x2F-Packet-out" class="headerlink" title="Packet-in&#x2F;Packet-out"></a>Packet-in&#x2F;Packet-out</h3><p>Interpreter 另外一個重要的功能是使 pipeline 支援 packet-in&#x2F;packet-out 的功能。為此我們需要先修改我們的 p4 pipeline。</p><p>首先我們會先加入兩個特別的 header，並使用 controller_header anotation 標記，<code>@controller_header (&quot;packet_in&quot;)</code> 來得知這個 packet_in_header_t 對應的是 packet-in 時，附加在這個封包的 meta data，通常會定義 ingress port 來表示封包的 input port。同樣的 packet_out_header_t 是 packet-out 時，ONOS 送來 pipeline 處理的 meta data</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@controller_header (&quot;packet_in&quot;)</span><br>header packet_in_header_t &#123;<br>    bit&lt;<span class="hljs-number">7</span>&gt; _padding;<br>    bit&lt;<span class="hljs-number">9</span>&gt; ingress_port;<br>&#125;<br><br><span class="hljs-meta">@controller_header (&quot;packet_out&quot;)</span><br>header packet_out_header_t &#123;<br>    bit&lt;<span class="hljs-number">7</span>&gt; _padding;<br>    bit&lt;<span class="hljs-number">9</span>&gt; egress_port;<br>&#125;<br></code></pre></td></tr></table></figure><p>接著我們要修改 header、parser，從 ONOS packet out 出來的封包對 p4 交換機來說相當於從特定一個 port 送進來的封包，因此一樣會經過整個 pipeline</p><blockquote><p>以 bmv2 來說，controller 的 port number 可以自由指定，在我們使用的 p4mn container 內這個 port 被定義成 255，為此我們在 pipeline 的 p4 檔案內定義了 CPU_PORT 巨集為 255</p></blockquote><p>我們將 packet-in&#x2F;packet-out header 加入到 headers 內，當 packet-out 時，packet_out 會在封包的開頭，因此在 parser 的 start state，我們先根據 ingress port 是不是 CPU_PORT 來決定是不是要 parse packet_out header。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">struct headers_t &#123;<br>    packet_in_header_t packet_in;<br>    packet_out_header_t packet_out;<br>    ethernet_h ethernet;<br>&#125;<br><br>parser <span class="hljs-title function_">MyParser</span><span class="hljs-params">(packet_in packet,</span><br><span class="hljs-params">                out headers_t hdr,</span><br><span class="hljs-params">                inout local_metadata_t meta,</span><br><span class="hljs-params">                inout standard_metadata_t standard_metadata)</span> &#123;<br><br>    state start &#123;<br>        transition <span class="hljs-title function_">select</span><span class="hljs-params">(standard_metadata.ingress_port)</span> &#123;<br>            CPU_PORT: parse_packet_out;<br>            <span class="hljs-keyword">default</span>: parse_ethernet;<br>        &#125;<br>    &#125;<br><br>    state parse_packet_out &#123;<br>        packet.extract (hdr.packet_out);<br>        transition parse_ethernet;<br>    &#125;<br><br>    state parse_ethernet &#123;<br>        packet.extract (hdr.ethernet);<br>        transition accept;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Ingress 部分，如果是 packet-out packet，我們沒有必要讓他經過整個 ingress pipeline，為此我們直接將 egress_spec 設置為 packet_out header 內的 egress_port，然後直接呼叫 exit。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">control <span class="hljs-title function_">MyIngress</span><span class="hljs-params">(inout headers_t hdr,</span><br><span class="hljs-params">                  inout local_metadata_t meta,</span><br><span class="hljs-params">                  inout standard_metadata_t standard_metadata)</span> &#123;<br>    apply &#123;<br>        <span class="hljs-keyword">if</span> (standard_metadata.ingress_port == CPU_PORT) &#123;<br>            standard_metadata.egress_spec = hdr.packet_out.egress_port;<br>            hdr.packet_out.setInvalid ();<br>            exit;<br>        &#125;<br>        table0_control.apply (hdr, meta, standard_metadata);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我們的 table0 則加入了 send_to_cpu 這個 action，做的事情就是把 egress_spec 設定成 CPU port。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">control <span class="hljs-title function_">table0_control</span><span class="hljs-params">(inout headers_t hdr,</span><br><span class="hljs-params">                inout local_metadata_t local_metadata,</span><br><span class="hljs-params">                inout standard_metadata_t standard_metadata)</span> &#123;<br>    action <span class="hljs-title function_">send_to_cpu</span><span class="hljs-params">()</span> &#123;<br>        standard_metadata.egress_spec = CPU_PORT;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>當封包要 packet-in 到 ONOS 時，需要將 packet-in header 設為 valid，並填入對應的資料，這個部分會再 Egress pipeline 完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">control <span class="hljs-title function_">MyEgress</span><span class="hljs-params">(inout headers_t hdr,</span><br><span class="hljs-params">                 inout local_metadata_t meta,</span><br><span class="hljs-params">                 inout standard_metadata_t standard_metadata)</span> &#123;<br>    apply &#123;<br>        <span class="hljs-keyword">if</span> (standard_metadata.egress_port == CPU_PORT) &#123;<br>            hdr.packet_in.setValid ();<br>            hdr.packet_in.ingress_port = standard_metadata.ingress_port;<br>            hdr.packet_in._padding = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最後為了讓 packet-in header 能後被傳到 ONOS，需要再 deparser 加入該 header，注意 packet-out header 是為了讓 pipeline 能夠根據該 header 來處理 pecket-out header 用的，因此他不應該被加入到 deparser。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">control <span class="hljs-title function_">MyDeparser</span><span class="hljs-params">(packet_out packet, in headers_t hdr)</span> &#123;<br>    apply &#123;<br>        packet.emit (hdr.packet_in);<br>        packet.emit (hdr.ethernet);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接著回到我們的 interpreter，在 interpreter 內定義了兩個函數 mapInboundPacket 和 mapOutboundPacket，分別對應 packet-in 和 packet-out 封包的處理。先前我們在 p4 pipeline 定義了 packet_in 和 packet_out 的 header，這兩個函數最基本的功能是讀取和寫入這兩個 header 的資訊。由於這兩個函數的功能相對固定，因此可以直接從 ONOS 的 <a href="https://github.com/opennetworkinglab/onos/blob/master/pipelines/basic/src/main/java/org/onosproject/pipelines/basic/BasicInterpreterImpl.java">basic pipeline interpreter</a> 複製過來修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Collection&lt;PiPacketOperation&gt; <span class="hljs-title function_">mapOutboundPacket</span><span class="hljs-params">(OutboundPacket packet)</span> <span class="hljs-keyword">throws</span> PiInterpreterException &#123;<br>      <span class="hljs-type">TrafficTreatment</span> <span class="hljs-variable">treatment</span> <span class="hljs-operator">=</span> packet.treatment ();<br><br>      <span class="hljs-comment">// 由於 outbound packet 的內容通常不用在 switch 上在做修改，因此我們只需要取得 </span><br>      <span class="hljs-comment">//set output port 的 instruction</span><br>      <span class="hljs-comment">// 當然如果有特別的功能需求，可以透過修改 pipeline 來支援更多 instruction</span><br>      List&lt;Instructions.OutputInstruction&gt; outInstructions = ...<br><br>      ImmutableList.Builder&lt;PiPacketOperation&gt; builder = ImmutableList.builder ();<br>      <span class="hljs-keyword">for</span> (Instructions.OutputInstruction outInst : outInstructions) &#123;<br>          ...<br>          <span class="hljs-comment">// 這邊透過呼叫 createPiPacketOperation 來填入 packet_out header 的資訊 </span><br>          builder.add (createPiPacketOperation (packet.data (), outInst.port ().toLong ()));<br>          ...<br>      &#125;<br>      <span class="hljs-keyword">return</span> builder.build ();<br>  &#125;<br><br><span class="hljs-keyword">private</span> PiPacketOperation <span class="hljs-title function_">createPiPacketOperation</span><span class="hljs-params">(ByteBuffer data, <span class="hljs-type">long</span> portNumber)</span><br>            <span class="hljs-keyword">throws</span> PiInterpreterException &#123;<br>        <span class="hljs-type">PiPacketMetadata</span> <span class="hljs-variable">metadata</span> <span class="hljs-operator">=</span> createPacketMetadata (portNumber);<br>        <span class="hljs-keyword">return</span> PiPacketOperation.builder ()<br>                .withType (PACKET_OUT)<br>                .withData (copyFrom (data))<br>                .withMetadatas (ImmutableList.of (metadata))<br>                .build ();<br>  &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> InboundPacket <span class="hljs-title function_">mapInboundPacket</span><span class="hljs-params">(PiPacketOperation packetIn, DeviceId deviceId)</span> <span class="hljs-keyword">throws</span> PiInterpreterException &#123;<br>    Ethernet ethPkt;<br>    ...<br>    ethPkt = Ethernet.deserializer ().deserialize (packetIn.data ().asArray (), <span class="hljs-number">0</span>,<br>    ...<br>    <span class="hljs-comment">//packet_in header 的資訊會以 key-value 的方式存在 packetIn.metadatas</span><br>Optional&lt;PiPacketMetadata&gt; packetMetadata = packetIn.metadatas ()<br>                .stream ().filter (m -&gt; m.id ().equals (INGRESS_PORT))<br>                .findFirst ()<br>    <span class="hljs-comment">// 從中提取出 input port number</span><br>    <span class="hljs-type">ImmutableByteSequence</span> <span class="hljs-variable">portByteSequence</span> <span class="hljs-operator">=</span> packetMetadata.get ().value ();<br>    <span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> portByteSequence.asReadOnlyBuffer ().getShort ();<br>    <span class="hljs-type">ConnectPoint</span> <span class="hljs-variable">receivedFrom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectPoint</span>(deviceId, PortNumber.portNumber (s));<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">rawData</span> <span class="hljs-operator">=</span> ByteBuffer.wrap (packetIn.data ().asArray ());<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultInboundPacket</span>(receivedFrom, ethPkt, rawData);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>到此我們已經完成了 interpreter 的實現了，Interpreter 目前還包含 <code>mapLogicalPortNumber</code> 和 <code>getOriginalDefaultAction</code> ，不過基本的 interpreter 不需要實現這兩個功能，所以這邊就不再展開介紹。</p><blockquote><p>同樣使用範例程式碼時，可以在 ONOS CLI 使用 <code>add-common-flow-rule &lt;device id&gt; &lt;input port&gt; &lt;output port&gt;</code> 的方式來使用下達 ONOS 標準的 flow rule。詳情可以 <a href="https://github.com/gamerslouis/onos-p4-tutorial/blob/master/simpleswitch/src/main/java/me/louisif/pipelines/simpleswitch/cli/AddFlowRule.java">參考檔案</a>。</p></blockquote><h2 id="撰寫-Pipeliner"><a href="#撰寫-Pipeliner" class="headerlink" title="撰寫 Pipeliner"></a>撰寫 Pipeliner</h2><p>到目前為止我們已經完成了 pipeconf 的基本功能，可以下 flow rule 還有使用 packet-in&#x2F;packet-out 的功能，不過到目前我們還是需要直接使用 flow rule，要知道 table id 對應的功能，為了能夠隱藏 table 的細節還有銜接 ONOS 內建的網路功能 APP，我們需要實作 pipeliner 讓我們的交換機支援 flow objective 的功能。</p><p>和 Interpreter 類似，我們需要實作 <code>Pipeliner</code> 這個介面並繼承 <code>AbstractHandlerBehaviour</code> 然後在 PipeconfLoader 透過 <code>addBehaviour (Pipeliner.class, SimpleSwitchPipeliner.class)</code> 的方式加入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleSwitchPipeliner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractHandlerBehaviour</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Pipeliner</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> getLogger (getClass ());<br><br>    <span class="hljs-keyword">private</span> FlowRuleService flowRuleService;<br>    <span class="hljs-keyword">private</span> DeviceId deviceId;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(DeviceId deviceId, PipelinerContext context)</span> &#123;<br>        <span class="hljs-built_in">this</span>.deviceId = deviceId;<br>        <span class="hljs-built_in">this</span>.flowRuleService = context.directory ().get (FlowRuleService.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先我們實作 init 方法，pipeliner 和交換機之間是 1 對 1 的關係，因此當交換機被初始化的時候，可以透過 init 方法取得 device 的 id。context 最主要的部份是使用 directory ().get 方法。平常我們在 APP 開發時是使用 Reference annotation 來取得 onos 的 service，這邊我們可以直接透過 get 方法來取得 service，由於 pipeliner 需要完成 flow ojbective 到 flow rule 的轉換，並直接送到 flow rule service，因此這邊先取得 flow rule service。</p><p>在 ONOS Flow Objective Service 的架構內，其實總共有三種 objective，分別是 forward、filter 和 next，他們都需要透過 pipeliner 來和 ONOS 核心互動，由於我們只想要實作 forwarding objective 的部分，因此 filter 和 next 可以單純回應不支援的錯誤訊息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">filter</span><span class="hljs-params">(FilteringObjective obj)</span> &#123;<br>    obj.context ().ifPresent (c -&gt; c.onError (obj, ObjectiveError.UNSUPPORTED));<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">next</span><span class="hljs-params">(NextObjective obj)</span> &#123;<br>    obj.context ().ifPresent (c -&gt; c.onError (obj, ObjectiveError.UNSUPPORTED));<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">getNextMappings</span><span class="hljs-params">(NextGroup nextGroup)</span> &#123;<br>    <span class="hljs-comment">// We do not use nextObjectives or groups.</span><br>    <span class="hljs-keyword">return</span> Collections.emptyList ();<br>&#125;<br></code></pre></td></tr></table></figure><p>接著就到了我們的主角 forward objective，在實作邏輯上其實與 interpreter 對 treatment 的處理方式類似，forward 方法會取得一個 ForwardingObjective 物件，我們根據 treatment 和 selector 生成出一條或多條 flow rule，然後透過 flow rule service 下放到交換機上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forward</span><span class="hljs-params">(ForwardingObjective obj)</span> &#123;<br>    <span class="hljs-keyword">if</span> (obj.treatment () == <span class="hljs-literal">null</span>) &#123;<br>        obj.context ().ifPresent (c -&gt; c.onError (obj, ObjectiveError.UNSUPPORTED));<br>    &#125;<br><br>    <span class="hljs-comment">// Simply create an equivalent FlowRule for table 0.</span><br>    <span class="hljs-keyword">final</span> FlowRule.<span class="hljs-type">Builder</span> <span class="hljs-variable">ruleBuilder</span> <span class="hljs-operator">=</span> DefaultFlowRule.builder ()<br>            .forTable (MY_INGRESS_TABLE0_CONTROL_TABLE0)<br>            .forDevice (deviceId)<br>            .withSelector (obj.selector ())<br>            .fromApp (obj.appId ())<br>            .withPriority (obj.priority ())<br>            .withTreatment (obj.treatment ());<br><br>    <span class="hljs-keyword">if</span> (obj.permanent ()) &#123;<br>        ruleBuilder.makePermanent ();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ruleBuilder.makeTemporary (obj.timeout ());<br>    &#125;<br><br>    <span class="hljs-keyword">switch</span> (obj.op ()) &#123;<br>        <span class="hljs-keyword">case</span> ADD:<br>            flowRuleService.applyFlowRules (ruleBuilder.build ());<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> REMOVE:<br>            flowRuleService.removeFlowRules (ruleBuilder.build ());<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            log.warn (<span class="hljs-string">&quot;Unknown operation &#123;&#125;&quot;</span>, obj.op ());<br>    &#125;<br><br>    obj.context ().ifPresent (c -&gt; c.onSuccess (obj));<br>&#125;<br></code></pre></td></tr></table></figure><p>最後我們還需要實作 purgeAll，當刪除所有 flow obejctive 的時候，刪除所有的 flow rule，這邊我們只需要簡單呼叫 flow rule service 的 purgeFlowRules 就好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">purgeAll</span><span class="hljs-params">(ApplicationId appId)</span> &#123;<br>    flowRuleService.purgeFlowRules (deviceId, appId);<br>&#125;<br></code></pre></td></tr></table></figure><p>到此我們已經完成了整個 pipeconf 的實作，可以透過 flow objective 的方式來管理交換機並與 ONOS 內建的 APP 整合，因此我們可以透過使用 <code>proxyarp</code> 和 <code>fwd</code> 兩個 APP 來讓我們的交換機能夠正常的工作。</p><h2 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h2><p>以上就是 ONOS P4 Pipeconf 的基本開發教學，使用的範例程式碼在 <a href="https://github.com/gamerslouis/onos-p4-tutorial">github</a>，如果有遇到任何問題或有說明不清楚的地方，歡迎留言提問，我會盡力為大家解答。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://hackmd.io/@cnsrl/onos_p4">https:&#x2F;&#x2F;hackmd.io&#x2F;@cnsrl&#x2F;onos_p4</a></p><p><a href="https://wiki.onosproject.org/pages/viewpage.action?pageId=16122675">https://wiki.onosproject.org/pages/viewpage.action?pageId=16122675</a></p><p><a href="https://github.com/p4lang/tutorials/blob/master/exercises/basic/solution/basic.p4">https://github.com/p4lang/tutorials/blob/master/exercises/basic/solution/basic.p4</a></p><p><a href="https://github.com/opennetworkinglab/onos/tree/master/pipelines/basic/src/main/java/org/onosproject/pipelines/basic">ONOS Basic Pipeline</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;這篇文章會介紹一下，在 ONOS 上 P4 相關的模組和功能，以及怎麼開發 ONOS APP 與設置 ONOS，讓 ONOS 可以控制 p4 switch 的 pipeline。&lt;/p&gt;</summary>
    
    
    
    <category term="ONOS" scheme="https://blog.louisif.me/categories/ONOS/"/>
    
    
    <category term="P4" scheme="https://blog.louisif.me/tags/P4/"/>
    
  </entry>
  
  <entry>
    <title>分析 ONOS Packet Processor Treatment 無效之原因</title>
    <link href="https://blog.louisif.me/ONOS/Analyze-why-ONOS-Packet-Processor-Treatment-not-Work/"/>
    <id>https://blog.louisif.me/ONOS/Analyze-why-ONOS-Packet-Processor-Treatment-not-Work/</id>
    <published>2022-08-12T03:26:42.000Z</published>
    <updated>2022-08-27T17:43:33.598Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ONOS 踩坑日記</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近嘗試使用 ONOS 目前最新的 2.7 版來開發 APP，用 OpenFlow 來讓交換機實現 router 的功能。結果踩到 ONOS Packet-in 封包處理實作未完全的坑。</p><span id="more"></span> <p>當封包經過 router 時，會根據 routing table 和封包的目標決定要往哪個 interface 送出，同時將封包的 source mac address 改為交換機的 mac address、封包的 destination mac address 改為 nexthop 的 mac address。因此我們需要在交換機上安裝一條 flow rule，selector 是 destination mac address，treatment 有三個 instructions 分別是：修改 src mac、dst mac 和決定 output port。</p><p>為了減少交換機上的 flow entry 的數量，所以採用 reactive 的方式，也就是當交換機收到第一封包時，先將封包送 (packet-in) 給 SDN controller，controller 根據 routing table，直接修改該封包的 mac address，並從交換機特定的 port 送出 (packet-out)，同時生成對應的 flow rule 並安裝到交換機上，後續的封包就可以直接根據 flow rule 轉送而不用再經過 controller。</p><h2 id="問題"><a href="#問題" class="headerlink" title="問題"></a>問題</h2><p>然而問題就出現在第一個封包上，根據 tcpdump 看到的結果，封包的 source 和 destination mac address 都沒有被修改到。</p><p>由於我是使用 OVS 來模擬 Openflow 交換機，因此首先懷疑是不是 OVS 本身實作限制，不支援同時包含上述三個 instructions 導致。然而，後續經過 flow rule 直接送出的封包，都有成功修改到 mac address。由於只有第一個 packet-in 到 controller，再 packet-out 回 switch 的封包沒有被修改，因此開始懷疑是 ONOS 的問題。</p><h2 id="追蹤"><a href="#追蹤" class="headerlink" title="追蹤"></a>追蹤</h2><p>在 ONOS 裡面，一般使用 PacketProcessor 的方式來處理 packet-in 到 controller 的封包。首先實作 PacketProcessor 介面，然後向 PacketService 註冊，ONOS 就會調用 processor 處理 packet-in 的封包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">PacketProcessor</span> <span class="hljs-variable">processor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PacketProcessor</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(PacketContext context)</span> &#123;<br>        <span class="hljs-comment">//.... 處理封包的邏輯 </span><br>        <span class="hljs-comment">// 修改設定封包的 mac address 和決定 output port</span><br>        context.treatmentBuilder ()<br>               .setEthSrc (srcMac)<br>               .setEthDst (dstMac)<br>               .setOutput (outPort.port ()); <br>        context.send (); <span class="hljs-comment">// 將封包 packet-out 回交換機 </span><br>    &#125;<br>&#125;;<br><span class="hljs-meta">@Activate</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">activate</span><span class="hljs-params">()</span> &#123;<br>    packetService.addProcessor (processor,      <br>         PacketProcessor.director (<span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>PacketContext 會包含 packet-in 進來的封包內容，並可透過 context.treatmentBuilder 修改封包和決定要往哪個 port 送出去，最後透過 send 指令，packet-out 回交換機。</p><p>搜查一下 ONOS 的原始碼，會在 core&#x2F;api 下面找到 DefaultPacketContext ，這個 class 實作了 PacketContext 這個 Interface，但是這個 class 是一個 abstract class，因此一定有人繼承了它，繼續搜查 PacketContext 這個字會找到兩個跟 Openflow 相關的，DefaultOpenFlowPacketContext 和 OpenFlowCorePacketContext，但是後者才有繼承 DefaultPacketContext 和實作 PacketContext 介面，因此 PacketProcesser 在處理 openflow packet-in 進來的封包時，拿到的 PacketContext 具體應該是 OpenFlowCorePacketContext 這個 class。</p><p>打開 OpenFlowCorePacketContext.java 會看到它實現了 send 這個 function，經過簡單的檢查後呼叫 sendPacket 這個 function，然後你就會看到…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendPacket</span><span class="hljs-params">(Ethernet eth)</span> &#123;<br>        List&lt;Instruction&gt; ins = treatmentBuilder ().build ().allInstructions ();<br>        <span class="hljs-type">OFPort</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> support arbitrary list of treatments must be supported in ofPacketContext</span><br>        <span class="hljs-keyword">for</span> (Instruction i : ins) &#123;<br>            <span class="hljs-keyword">if</span> (i.type () == Type.OUTPUT) &#123;<br>                p = buildPort (((OutputInstruction) i).port ());<br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">//for now...</span><br>            &#125;<br>        &#125;<br>        .......<br>&#125;<br></code></pre></td></tr></table></figure><p>謎底揭曉，原來 ONOS 只有實作 output 這個 instruction (決定 output port)，因此它直接忽略的 set source mac 和 set destination mac 兩個指令，交換機送出來的封包當然就只有往對的 port 送，而沒有改到 mac address。</p><h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>結論就是在當前 ONOS 2.7 環境下，PacketProcesser 在處理 Openflow 交換機封包 packet-out 的時候，只能決定該封包的 output port，其餘對該封包的修改都是無效的。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://github.com/opennetworkinglab/onos/">ONOS Source code</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;ONOS 踩坑日記&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近嘗試使用 ONOS 目前最新的 2.7 版來開發 APP，用 OpenFlow 來讓交換機實現 router 的功能。結果踩到 ONOS Packet-in 封包處理實作未完全的坑。&lt;/p&gt;</summary>
    
    
    
    <category term="ONOS" scheme="https://blog.louisif.me/categories/ONOS/"/>
    
    
  </entry>
  
</feed>
